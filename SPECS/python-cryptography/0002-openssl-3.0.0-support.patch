From e9df1f9fec98c931c33125811486d1ea352d3606 Mon Sep 17 00:00:00 2001
From: Paul Kehrer <paul.l.kehrer@gmail.com>
Date: Sun, 29 Aug 2021 10:05:32 -0400
Subject: [PATCH] FIPS 3.0.0 support (#6012)

* FIPS 3.0.0 support

* comments

* remove unneeded error clear

* review comments

* small refactor

* black

* flake8 too

* review feedback

* oops

* fix

[psinghchauha: From original patch removed changes of .github/ not present in source tar,
               removed decorators and other changes from tests which were not needed]

Signed-off-by: Prashant S Chauhan <psinghchauha@vmware.com>
---
 src/_cffi_src/build_openssl.py                |  3 +-
 src/_cffi_src/openssl/evp.py                  | 12 ++++
 .../hazmat/backends/openssl/backend.py        | 68 +++++++++++++++++--
 .../hazmat/bindings/openssl/_conditional.py   |  8 +++
 .../hazmat/bindings/openssl/binding.py        | 16 +++++
 tests/conftest.py                             |  6 ++
 tests/hazmat/primitives/test_dh.py            |  2 +
 tests/hazmat/primitives/test_pkcs12.py        | 10 ++-
 tests/hazmat/primitives/test_pkcs7.py         | 10 ++-
 tests/hazmat/primitives/test_serialization.py | 18 ++++-
 tests/wycheproof/test_hmac.py                 |  2 +-
 tests/wycheproof/test_rsa.py                  |  7 ++
 14 files changed, 166 insertions(+), 17 deletions(-)

diff --git a/src/_cffi_src/build_openssl.py b/src/_cffi_src/build_openssl.py
index 557296ed535..723f82e13db 100644
--- a/src/_cffi_src/build_openssl.py
+++ b/src/_cffi_src/build_openssl.py
@@ -79,6 +79,8 @@ def _extra_compile_args(platform):
     modules=[
         # This goes first so we can define some cryptography-wide symbols.
         "cryptography",
+        # Provider comes early as well so we define OSSL_LIB_CTX
+        "provider",
         "aes",
         "asn1",
         "bignum",
@@ -104,7 +106,6 @@ def _extra_compile_args(platform):
         "osrandom_engine",
         "pem",
         "pkcs12",
-        "provider",
         "rand",
         "rsa",
         "ssl",
diff --git a/src/_cffi_src/openssl/evp.py b/src/_cffi_src/openssl/evp.py
index 2b2f995e389..735b8c37cfa 100644
--- a/src/_cffi_src/openssl/evp.py
+++ b/src/_cffi_src/openssl/evp.py
@@ -36,6 +36,7 @@
 static const int Cryptography_HAS_ONESHOT_EVP_DIGEST_SIGN_VERIFY;
 static const long Cryptography_HAS_RAW_KEY;
 static const long Cryptography_HAS_EVP_DIGESTFINAL_XOF;
+static const long Cryptography_HAS_300_FIPS;
 """
 
 FUNCTIONS = """
@@ -165,6 +166,9 @@
                                       size_t);
 int EVP_PKEY_get_raw_private_key(const EVP_PKEY *, unsigned char *, size_t *);
 int EVP_PKEY_get_raw_public_key(const EVP_PKEY *, unsigned char *, size_t *);
+
+int EVP_default_properties_is_fips_enabled(OSSL_LIB_CTX *);
+int EVP_default_properties_enable_fips(OSSL_LIB_CTX *, int);
 """
 
 CUSTOMIZATIONS = """
@@ -269,4 +273,12 @@
 #ifndef EVP_PKEY_POLY1305
 #define EVP_PKEY_POLY1305 NID_poly1305
 #endif
+
+#if CRYPTOGRAPHY_OPENSSL_300_OR_GREATER
+static const long Cryptography_HAS_300_FIPS = 1;
+#else
+static const long Cryptography_HAS_300_FIPS = 0;
+int (*EVP_default_properties_is_fips_enabled)(OSSL_LIB_CTX *) = NULL;
+int (*EVP_default_properties_enable_fips)(OSSL_LIB_CTX *, int) = NULL;
+#endif
 """
diff --git a/src/cryptography/hazmat/backends/openssl/backend.py b/src/cryptography/hazmat/backends/openssl/backend.py
index 86e8f0a8813..2363a6069ed 100644
--- a/src/cryptography/hazmat/backends/openssl/backend.py
+++ b/src/cryptography/hazmat/backends/openssl/backend.py
@@ -196,8 +196,9 @@ class Backend(object):
         b"aes-256-gcm",
     }
     _fips_ciphers = (AES, TripleDES)
+    # Sometimes SHA1 is still permissible. That logic is contained
+    # within the various *_supported methods.
     _fips_hashes = (
-        hashes.SHA1,
         hashes.SHA224,
         hashes.SHA256,
         hashes.SHA384,
@@ -211,6 +212,12 @@ class Backend(object):
         hashes.SHAKE128,
         hashes.SHAKE256,
     )
+    _fips_ecdh_curves = (
+        ec.SECP224R1,
+        ec.SECP256R1,
+        ec.SECP384R1,
+        ec.SECP521R1,
+    )
     _fips_rsa_min_key_size = 2048
     _fips_rsa_min_public_exponent = 65537
     _fips_dsa_min_modulus = 1 << 2048
@@ -238,17 +245,34 @@ def __init__(self):
         if self._lib.Cryptography_HAS_EVP_PKEY_DHX:
             self._dh_types.append(self._lib.EVP_PKEY_DHX)
 
+    def __repr__(self):
+        return "<OpenSSLBackend(version: {}, FIPS: {})>".format(
+            self.openssl_version_text(), self._fips_enabled
+        )
+
     def openssl_assert(self, ok, errors=None):
         return binding._openssl_assert(self._lib, ok, errors=errors)
 
     def _is_fips_enabled(self):
-        fips_mode = getattr(self._lib, "FIPS_mode", lambda: 0)
-        mode = fips_mode()
+        if self._lib.Cryptography_HAS_300_FIPS:
+            mode = self._lib.EVP_default_properties_is_fips_enabled(
+                self._ffi.NULL
+            )
+        else:
+            mode = getattr(self._lib, "FIPS_mode", lambda: 0)()
+
         if mode == 0:
             # OpenSSL without FIPS pushes an error on the error stack
             self._lib.ERR_clear_error()
         return bool(mode)
 
+    def _enable_fips(self):
+        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that
+        # have the FIPS provider installed properly.
+        self._binding._enable_fips()
+        assert self._is_fips_enabled()
+        self._fips_enabled = self._is_fips_enabled()
+
     def activate_builtin_random(self):
         if self._lib.CRYPTOGRAPHY_NEEDS_OSRANDOM_ENGINE:
             # Obtain a new structural reference.
@@ -343,15 +367,32 @@ def hash_supported(self, algorithm):
         evp_md = self._evp_md_from_algorithm(algorithm)
         return evp_md != self._ffi.NULL
 
+    def scrypt_supported(self):
+        if self._fips_enabled:
+            return False
+        else:
+            return self._lib.Cryptography_HAS_SCRYPT == 1
+
     def hmac_supported(self, algorithm):
+        # FIPS mode still allows SHA1 for HMAC
+        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):
+            return True
+
         return self.hash_supported(algorithm)
 
     def create_hash_ctx(self, algorithm):
         return _HashContext(self, algorithm)
 
     def cipher_supported(self, cipher, mode):
-        if self._fips_enabled and not isinstance(cipher, self._fips_ciphers):
-            return False
+        if self._fips_enabled:
+            # FIPS mode requires AES or TripleDES, but only CBC/ECB allowed
+            # in TripleDES mode.
+            if not isinstance(cipher, self._fips_ciphers) or (
+                isinstance(cipher, TripleDES)
+                and not isinstance(mode, (CBC, ECB))
+            ):
+                return False
+
         try:
             adapter = self._cipher_registry[type(cipher), type(mode)]
         except KeyError:
@@ -767,7 +808,13 @@ def rsa_padding_supported(self, padding):
         if isinstance(padding, PKCS1v15):
             return True
         elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):
-            return self.hash_supported(padding._mgf._algorithm)
+            # SHA1 is permissible in MGF1 in FIPS
+            if self._fips_enabled and isinstance(
+                padding._mgf._algorithm, hashes.SHA1
+            ):
+                return True
+            else:
+                return self.hash_supported(padding._mgf._algorithm)
         elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):
             return (
                 self._oaep_hash_supported(padding._mgf._algorithm)
@@ -1509,10 +1556,12 @@ def _handle_key_loading_error(self):
             raise ValueError("Unsupported public key algorithm.")
 
         else:
+            errors = binding._errors_with_text(errors)
             raise ValueError(
                 "Could not deserialize key data. The data may be in an "
                 "incorrect format or it may be encrypted with an unsupported "
-                "algorithm."
+                "algorithm.",
+                errors,
             )
 
     def elliptic_curve_supported(self, curve):
@@ -1794,6 +1843,11 @@ def create_ocsp_response(
         return _OCSPResponse(self, ocsp_resp)
 
     def elliptic_curve_exchange_algorithm_supported(self, algorithm, curve):
+        if self._fips_enabled and not isinstance(
+            curve, self._fips_ecdh_curves
+        ):
+            return False
+
         return self.elliptic_curve_supported(curve) and isinstance(
             algorithm, ec.ECDH
         )
diff --git a/src/cryptography/hazmat/bindings/openssl/_conditional.py b/src/cryptography/hazmat/bindings/openssl/_conditional.py
index 8810db1..d7c05fb 100644
--- a/src/cryptography/hazmat/bindings/openssl/_conditional.py
+++ b/src/cryptography/hazmat/bindings/openssl/_conditional.py
@@ -279,6 +279,14 @@ def cryptography_has_providers():
         "PROV_R_BAD_DECRYPT",
     ]
 
+
+def cryptography_has_300_fips():
+    return [
+        "EVP_default_properties_is_fips_enabled",
+        "EVP_default_properties_enable_fips",
+    ]
+
+
 # This is a mapping of
 # {condition: function-returning-names-dependent-on-that-condition} so we can
 # loop over them and delete unsupported names at runtime. It will be removed
@@ -327,4 +335,5 @@ CONDITIONAL_NAMES = {
     "Cryptography_HAS_VERIFIED_CHAIN": cryptography_has_verified_chain,
     "Cryptography_HAS_SRTP": cryptography_has_srtp,
     "Cryptography_HAS_GET_PROTO_VERSION": cryptography_has_get_proto_version,
+    "Cryptography_HAS_300_FIPS": cryptography_has_300_fips,
 }
diff --git a/src/cryptography/hazmat/bindings/openssl/binding.py b/src/cryptography/hazmat/bindings/openssl/binding.py
index f651ab67238..92d5b2448a4 100644
--- a/src/cryptography/hazmat/bindings/openssl/binding.py
+++ b/src/cryptography/hazmat/bindings/openssl/binding.py
@@ -116,6 +116,22 @@ class Binding(object):
     def __init__(self):
         self._ensure_ffi_initialized()
 
+    def _enable_fips(self):
+        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that
+        # have the FIPS provider installed properly.
+        _openssl_assert(self.lib, self.lib.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER)
+        self._base_provider = self.lib.OSSL_PROVIDER_load(
+            self.ffi.NULL, b"base"
+        )
+        _openssl_assert(self.lib, self._base_provider != self.ffi.NULL)
+        self.lib._fips_provider = self.lib.OSSL_PROVIDER_load(
+            self.ffi.NULL, b"fips"
+        )
+        _openssl_assert(self.lib, self.lib._fips_provider != self.ffi.NULL)
+
+        res = self.lib.EVP_default_properties_enable_fips(self.ffi.NULL, 1)
+        _openssl_assert(self.lib, res == 1)
+
     @classmethod
     def _register_osrandom_engine(cls):
         # Clear any errors extant in the queue before we start. In many
diff --git a/tests/conftest.py b/tests/conftest.py
index ece7a11..006e14e 100644
--- a/tests/conftest.py
+++ b/tests/conftest.py
@@ -14,6 +14,11 @@ from .utils import (
 )
 
 
+def pytest_configure(config):
+    if config.getoption("--enable-fips"):
+        openssl_backend._enable_fips()
+
+
 def pytest_report_header(config):
     return "\n".join(
         [
@@ -25,7 +30,7 @@ def pytest_report_header(config):
 
 def pytest_addoption(parser):
     parser.addoption("--wycheproof-root", default=None)
-
+    parser.addoption("--enable-fips", default=False)
 
 def pytest_generate_tests(metafunc):
     if "wycheproof" in metafunc.fixturenames:
diff --git a/tests/hazmat/primitives/test_dh.py b/tests/hazmat/primitives/test_dh.py
index 2914f7e776f..f6bf8fea3c2 100644
--- a/tests/hazmat/primitives/test_dh.py
+++ b/tests/hazmat/primitives/test_dh.py
@@ -675,6 +675,7 @@ def test_public_bytes(self, backend, encoding, loader_func):
         pub_num = key.public_numbers()
         assert loaded_pub_num == pub_num
 
+    @pytest.mark.skip_fips(reason="non-FIPS parameters")
     @pytest.mark.parametrize(
         ("key_path", "loader_func", "encoding", "is_dhx"),
         [
@@ -718,6 +719,7 @@ def test_public_bytes_match(
         )
         assert serialized == key_bytes
 
+    @pytest.mark.skip_fips(reason="non-FIPS parameters")
     @pytest.mark.parametrize(
         ("key_path", "loader_func", "vec_path", "is_dhx"),
         [
diff --git a/tests/hazmat/primitives/test_pkcs12.py b/tests/hazmat/primitives/test_pkcs12.py
index b1759a1bc8a..65f5b283018 100644
--- a/tests/hazmat/primitives/test_pkcs12.py
+++ b/tests/hazmat/primitives/test_pkcs12.py
@@ -24,6 +24,9 @@
 
 
 @pytest.mark.requires_backend_interface(interface=DERSerializationBackend)
+@pytest.mark.skip_fips(
+    reason="PKCS12 unsupported in FIPS mode. So much bad crypto in it."
+)
 class TestPKCS12Loading(object):
     def _test_load_pkcs12_ec_keys(self, filename, password, backend):
         cert = load_vectors_from_file(
@@ -72,7 +75,6 @@ def test_load_pkcs12_ec_keys(self, filename, password, backend):
         only_if=lambda backend: backend.cipher_supported(_RC2(), None),
         skip_message="Does not support RC2",
     )
-    @pytest.mark.skip_fips(reason="Unsupported algorithm in FIPS mode")
     def test_load_pkcs12_ec_keys_rc2(self, filename, password, backend):
         self._test_load_pkcs12_ec_keys(filename, password, backend)
 
@@ -169,6 +171,9 @@ def _load_ca(backend):
     return cert, key
 
 
+@pytest.mark.skip_fips(
+    reason="PKCS12 unsupported in FIPS mode. So much bad crypto in it."
+)
 class TestPKCS12Creation(object):
     @pytest.mark.parametrize("name", [None, b"name"])
     @pytest.mark.parametrize(
diff --git a/tests/hazmat/primitives/test_pkcs7.py b/tests/hazmat/primitives/test_pkcs7.py
index 6bc65eef310..2f1ecb3bb46 100644
--- a/tests/hazmat/primitives/test_pkcs7.py
+++ b/tests/hazmat/primitives/test_pkcs7.py
@@ -331,6 +331,9 @@ def test_sign_pem(self, backend):
     def test_sign_alternate_digests_der(
         self, hash_alg, expected_value, backend
     ):
+        if isinstance(hash_alg, hashes.SHA1) and backend._fips_enabled:
+            pytest.skip("SHA1 not supported in FIPS mode")
+
         data = b"hello world"
         cert, key = _load_cert_key()
         builder = (
@@ -354,7 +357,12 @@ def test_sign_alternate_digests_der(
             (hashes.SHA512(), b"sha-512"),
         ],
     )
-    def test_sign_alternate_digests_detached(self, hash_alg, expected_value):
+    def test_sign_alternate_digests_detached(
+        self, hash_alg, expected_value, backend
+    ):
+        if isinstance(hash_alg, hashes.SHA1) and backend._fips_enabled:
+            pytest.skip("SHA1 not supported in FIPS mode")
+
         data = b"hello world"
         cert, key = _load_cert_key()
         builder = (
diff --git a/tests/hazmat/primitives/test_serialization.py b/tests/hazmat/primitives/test_serialization.py
index ca969e031cf..44bb55acd4d 100644
--- a/tests/hazmat/primitives/test_serialization.py
+++ b/tests/hazmat/primitives/test_serialization.py
@@ -59,8 +59,19 @@ def _skip_fips_format(key_path, password, backend):
     if backend._fips_enabled:
         if key_path[0] == "Traditional_OpenSSL_Serialization":
             pytest.skip("Traditional OpenSSL format blocked in FIPS mode")
-        if key_path[0] == "PEM_Serialization" and password is not None:
-            pytest.skip("Encrypted PEM_Serialization blocked in FIPS mode")
+        if (
+            key_path[0] in ("PEM_Serialization", "PKCS8")
+            and password is not None
+        ):
+            pytest.skip(
+                "The encrypted PEM vectors currently have encryption "
+                "that is not FIPS approved in the 3.0 provider"
+            )
+        if key_path[0] == "DER_Serialization" and password is not None:
+            pytest.skip(
+                "The encrypted PKCS8 DER vectors currently have encryption "
+                "that is not FIPS approved in the 3.0 provider"
+            )
 
 
 class TestBufferProtocolSerialization(object):
@@ -75,6 +86,7 @@ class TestBufferProtocolSerialization(object):
         ],
     )
     def test_load_der_rsa_private_key(self, key_path, password, backend):
+        _skip_fips_format(key_path, password, backend)
         data = load_vectors_from_file(
             os.path.join("asymmetric", *key_path),
             lambda derfile: derfile.read(),
@@ -128,6 +140,7 @@ class TestDERSerialization(object):
         ],
     )
     def test_load_der_rsa_private_key(self, key_path, password, backend):
+        _skip_fips_format(key_path, password, backend)
         key = load_vectors_from_file(
             os.path.join("asymmetric", *key_path),
             lambda derfile: load_der_private_key(
@@ -837,6 +850,7 @@ def test_pks8_encrypted_corrupt_format(self, backend):
         with pytest.raises(ValueError):
             load_pem_private_key(key_data, password, backend)
 
+    @pytest.mark.skip_fips(reason="non-FIPS parameters")
     def test_rsa_pkcs8_encrypted_values(self, backend):
         pkey = load_vectors_from_file(
             os.path.join("asymmetric", "PKCS8", "enc-rsa-pkcs8.pem"),
diff --git a/tests/wycheproof/test_hmac.py b/tests/wycheproof/test_hmac.py
index bfc69079512..84b0c19a053 100644
--- a/tests/wycheproof/test_hmac.py
+++ b/tests/wycheproof/test_hmac.py
@@ -41,7 +41,7 @@ def test_hmac(backend, wycheproof):
     hash_algo = _HMAC_ALGORITHMS[wycheproof.testfiledata["algorithm"]]
     if wycheproof.testgroup["tagSize"] // 8 != hash_algo.digest_size:
         pytest.skip("Truncated HMAC not supported")
-    if not backend.hash_supported(hash_algo):
+    if not backend.hmac_supported(hash_algo):
         pytest.skip("Hash {} not supported".format(hash_algo.name))
 
     h = hmac.HMAC(
diff --git a/tests/wycheproof/test_rsa.py b/tests/wycheproof/test_rsa.py
index 926bb44..7ed4ba2 100644
--- a/tests/wycheproof/test_rsa.py
+++ b/tests/wycheproof/test_rsa.py
@@ -100,6 +100,13 @@ def test_rsa_pkcs1v15_signature_generation(backend, wycheproof):
         backend=backend,
     )
     digest = _DIGESTS[wycheproof.testgroup["sha"]]
+    if backend._fips_enabled:
+        if key.key_size < 2048 or isinstance(digest, hashes.SHA1):
+            pytest.skip(
+                "Invalid params for FIPS. key: {} bits, digest: {}".format(
+                    key.key_size, digest.name
+                )
+            )
 
     sig = key.sign(
         binascii.unhexlify(wycheproof.testcase["msg"]),
