From 422bec25ae4a1ab03fd4d6f728695ed279173b18 Mon Sep 17 00:00:00 2001
From: "Andrew G. Morgan" <morgan@kernel.org>
Date: Wed, 3 May 2023 19:44:22 -0700
Subject: Large strings can confuse libcap's internal strdup code.

Avoid something subtle with really long strings: 1073741823 should
be enough for anybody. This is an improved fix over something attempted
in libcap-2.55 to address some static analysis findings.

Reviewing the library, cap_proc_root() and cap_launcher_set_chroot()
are the only two calls where the library is potentially exposed to a
user controlled string input.

Credit for finding this bug in libcap goes to Richard Weinberger of
X41 D-Sec GmbH (https://x41-dsec.de/) who performed a security audit
of the libcap source code in April of 2023. The audit was sponsored
by the Open Source Technology Improvement Fund (https://ostif.org/).

Audit ref: LCAP-CR-23-02 (CVE-2023-2603)

This also includes changes done to _libcap_strdup from following
commits:

- a56162c6900d203c5ac63a2b41b46cb0c45c645f (Eliminate an alignment issue found by clang).
- de1130dbfe6d4ce99422b11cac147d39448bcd40 (Speculative fix for build failure).
- 6c38eb78d96a60a9503dc5c89ade67b65778fed9 (Avoid the build server failure).

Signed-off-by: Andrew G. Morgan <morgan@kernel.org>
Signed-off-by: Piyush Gupta <gpiyush@vmware.com>
---
 libcap/cap_alloc.c | 43 +++++++++++++++++++++++++++++++++++--------
 1 file changed, 35 insertions(+), 8 deletions(-)

diff --git a/libcap/cap_alloc.c b/libcap/cap_alloc.c
index 6dab4e6..88cddf5 100644
--- a/libcap/cap_alloc.c
+++ b/libcap/cap_alloc.c
@@ -24,6 +24,19 @@ cap_value_t cap_max_bits(void) {
     return _cap_max_bits;
 }
 
+/*
+ * capability allocation is all done in terms of this structure.
+ */
+struct _cap_alloc_s {
+    __u32 magic;
+    __u32 size;
+    union {
+	struct _cap_struct set;
+	struct cap_iab_s iab;
+	struct cap_launch_s launcher;
+    } u;
+};
+
 /*
  * Obtain a blank set of capabilities
  */
@@ -72,26 +85,40 @@ cap_t cap_init(void)
  * This is an internal library function to duplicate a string and
  * tag the result as something cap_free can handle.
  */
-
-char *_libcap_strdup(const char *old)
+__attribute__((visibility ("hidden"))) char *_libcap_strdup(const char *old)
 {
-    __u32 *raw_data;
+    struct _cap_alloc_s *header;
+    char *raw_data;
+    size_t len;
 
     if (old == NULL) {
 	errno = EINVAL;
 	return NULL;
     }
 
-    raw_data = malloc( sizeof(__u32) + strlen(old) + 1 );
+    len = strlen(old);
+    if ((len & 0x3fffffff) != len) {
+	_cap_debug("len is too long for libcap to manage");
+	errno = EINVAL;
+	return NULL;
+    }
+    len += 1 + 2*sizeof(__u32);
+    if (len < sizeof(struct _cap_alloc_s)) {
+	len = sizeof(struct _cap_alloc_s);
+    }
+
+    raw_data = calloc(1, len);
     if (raw_data == NULL) {
 	errno = ENOMEM;
 	return NULL;
     }
+    header = (void *) raw_data;
+    header->magic = CAP_S_MAGIC;
+    header->size = (__u32) len;
 
-    *(raw_data++) = CAP_S_MAGIC;
-    strcpy((char *) raw_data, old);
-
-    return ((char *) raw_data);
+    raw_data += 2*sizeof(__u32);
+    strcpy(raw_data, old);
+    return raw_data;
 }
 
 /*
-- 
2.35.6

