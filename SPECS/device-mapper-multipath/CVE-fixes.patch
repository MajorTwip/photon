From MAILER-DAEMON Tue Sep 27 19:37:20 2022
>From f812466f68b8e020818c6454d7b7a7e278bc99f6 Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@suse.com>
Date: Wed, 24 Aug 2022 19:05:08 +0200
Subject: [PATCH v5 1/5] multipathd: more robust command parsing

The current parser allows commands like "path sda show" or "list list
add path sda", because it doesn't enforce ordering of the keywords
and simply adds rather than or-s the values of the keys.

Rework this by using a separate byte for the "verb" and the allowed
qualifiers in the different positions of the command. No command
needs more than 3 qualifiers, so we disallow command vectors with
more than 4 elements, and change the type of the fingerprint to
uint32_t.

init_callbacks() is now required in both multipathc and multipathd
to initialize the table of handlers and fingerprints. But as m
ultipathc never calls any handler, we need not link the
entire handlers code into it.

Signed-off-by: Martin Wilck <mwilck@suse.com>
Reviewed-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 multipathd/callbacks.c    | 126 +++++++++++++------------
 multipathd/cli.c          | 162 +++++++++++++++++---------------
 multipathd/cli.h          | 188 +++++++++++++++++++-------------------
 multipathd/cli_handlers.c |  70 +++++++-------
 multipathd/multipathc.c   |   6 +-
 multipathd/uxlsnr.c       |   2 +-
 6 files changed, 290 insertions(+), 264 deletions(-)

diff --git a/multipathd/callbacks.c b/multipathd/callbacks.c
index 0bd76b7..fb87b28 100644
--- a/multipathd/callbacks.c
+++ b/multipathd/callbacks.c
@@ -1,60 +1,72 @@
 void init_handler_callbacks(void)
 {
-	set_handler_callback(LIST+PATHS, HANDLER(cli_list_paths));
-	set_handler_callback(LIST+PATHS+FMT, HANDLER(cli_list_paths_fmt));
-	set_handler_callback(LIST+PATHS+RAW+FMT, HANDLER(cli_list_paths_raw));
-	set_handler_callback(LIST+PATH, HANDLER(cli_list_path));
-	set_handler_callback(LIST+MAPS, HANDLER(cli_list_maps));
-	set_handler_callback(LIST+STATUS, HANDLER(cli_list_status));
-	set_unlocked_handler_callback(LIST+DAEMON, HANDLER(cli_list_daemon));
-	set_handler_callback(LIST+MAPS+STATUS, HANDLER(cli_list_maps_status));
-	set_handler_callback(LIST+MAPS+STATS, HANDLER(cli_list_maps_stats));
-	set_handler_callback(LIST+MAPS+FMT, HANDLER(cli_list_maps_fmt));
-	set_handler_callback(LIST+MAPS+RAW+FMT, HANDLER(cli_list_maps_raw));
-	set_handler_callback(LIST+MAPS+TOPOLOGY, HANDLER(cli_list_maps_topology));
-	set_handler_callback(LIST+TOPOLOGY, HANDLER(cli_list_maps_topology));
-	set_handler_callback(LIST+MAPS+JSON, HANDLER(cli_list_maps_json));
-	set_handler_callback(LIST+MAP+TOPOLOGY, HANDLER(cli_list_map_topology));
-	set_handler_callback(LIST+MAP+FMT, HANDLER(cli_list_map_fmt));
-	set_handler_callback(LIST+MAP+RAW+FMT, HANDLER(cli_list_map_fmt));
-	set_handler_callback(LIST+MAP+JSON, HANDLER(cli_list_map_json));
-	set_handler_callback(LIST+CONFIG+LOCAL, HANDLER(cli_list_config_local));
-	set_handler_callback(LIST+CONFIG, HANDLER(cli_list_config));
-	set_handler_callback(LIST+BLACKLIST, HANDLER(cli_list_blacklist));
-	set_handler_callback(LIST+DEVICES, HANDLER(cli_list_devices));
-	set_handler_callback(LIST+WILDCARDS, HANDLER(cli_list_wildcards));
-	set_handler_callback(RESET+MAPS+STATS, HANDLER(cli_reset_maps_stats));
-	set_handler_callback(RESET+MAP+STATS, HANDLER(cli_reset_map_stats));
-	set_handler_callback(ADD+PATH, HANDLER(cli_add_path));
-	set_handler_callback(DEL+PATH, HANDLER(cli_del_path));
-	set_handler_callback(ADD+MAP, HANDLER(cli_add_map));
-	set_handler_callback(DEL+MAP, HANDLER(cli_del_map));
-	set_handler_callback(DEL+MAPS, HANDLER(cli_del_maps));
-	set_handler_callback(SWITCH+MAP+GROUP, HANDLER(cli_switch_group));
-	set_unlocked_handler_callback(RECONFIGURE, HANDLER(cli_reconfigure));
-	set_unlocked_handler_callback(RECONFIGURE+ALL, HANDLER(cli_reconfigure_all));
-	set_handler_callback(SUSPEND+MAP, HANDLER(cli_suspend));
-	set_handler_callback(RESUME+MAP, HANDLER(cli_resume));
-	set_handler_callback(RESIZE+MAP, HANDLER(cli_resize));
-	set_handler_callback(RELOAD+MAP, HANDLER(cli_reload));
-	set_handler_callback(RESET+MAP, HANDLER(cli_reassign));
-	set_handler_callback(REINSTATE+PATH, HANDLER(cli_reinstate));
-	set_handler_callback(FAIL+PATH, HANDLER(cli_fail));
-	set_handler_callback(DISABLEQ+MAP, HANDLER(cli_disable_queueing));
-	set_handler_callback(RESTOREQ+MAP, HANDLER(cli_restore_queueing));
-	set_handler_callback(DISABLEQ+MAPS, HANDLER(cli_disable_all_queueing));
-	set_handler_callback(RESTOREQ+MAPS, HANDLER(cli_restore_all_queueing));
-	set_unlocked_handler_callback(QUIT, HANDLER(cli_quit));
-	set_unlocked_handler_callback(SHUTDOWN, HANDLER(cli_shutdown));
-	set_handler_callback(GETPRSTATUS+MAP, HANDLER(cli_getprstatus));
-	set_handler_callback(SETPRSTATUS+MAP, HANDLER(cli_setprstatus));
-	set_handler_callback(UNSETPRSTATUS+MAP, HANDLER(cli_unsetprstatus));
-	set_handler_callback(FORCEQ+DAEMON, HANDLER(cli_force_no_daemon_q));
-	set_handler_callback(RESTOREQ+DAEMON, HANDLER(cli_restore_no_daemon_q));
-	set_handler_callback(GETPRKEY+MAP, HANDLER(cli_getprkey));
-	set_handler_callback(SETPRKEY+MAP+KEY, HANDLER(cli_setprkey));
-	set_handler_callback(UNSETPRKEY+MAP, HANDLER(cli_unsetprkey));
-	set_handler_callback(SETMARGINAL+PATH, HANDLER(cli_set_marginal));
-	set_handler_callback(UNSETMARGINAL+PATH, HANDLER(cli_unset_marginal));
-	set_handler_callback(UNSETMARGINAL+MAP, HANDLER(cli_unset_all_marginal));
+	set_handler_callback(VRB_LIST | Q1_PATHS, HANDLER(cli_list_paths));
+	set_handler_callback(VRB_LIST | Q1_PATHS | Q2_FMT, HANDLER(cli_list_paths_fmt));
+	set_handler_callback(VRB_LIST | Q1_PATHS | Q2_RAW | Q3_FMT,
+			     HANDLER(cli_list_paths_raw));
+	set_handler_callback(VRB_LIST | Q1_PATH, HANDLER(cli_list_path));
+	set_handler_callback(VRB_LIST | Q1_MAPS, HANDLER(cli_list_maps));
+	set_handler_callback(VRB_LIST | Q1_STATUS, HANDLER(cli_list_status));
+	set_unlocked_handler_callback(VRB_LIST | Q1_DAEMON, HANDLER(cli_list_daemon));
+	set_handler_callback(VRB_LIST | Q1_MAPS | Q2_STATUS,
+			     HANDLER(cli_list_maps_status));
+	set_handler_callback(VRB_LIST | Q1_MAPS | Q2_STATS,
+			     HANDLER(cli_list_maps_stats));
+	set_handler_callback(VRB_LIST | Q1_MAPS | Q2_FMT, HANDLER(cli_list_maps_fmt));
+	set_handler_callback(VRB_LIST | Q1_MAPS | Q2_RAW | Q3_FMT,
+			     HANDLER(cli_list_maps_raw));
+	set_handler_callback(VRB_LIST | Q1_MAPS | Q2_TOPOLOGY,
+			     HANDLER(cli_list_maps_topology));
+	set_handler_callback(VRB_LIST | Q1_TOPOLOGY, HANDLER(cli_list_maps_topology));
+	set_handler_callback(VRB_LIST | Q1_MAPS | Q2_JSON, HANDLER(cli_list_maps_json));
+	set_handler_callback(VRB_LIST | Q1_MAP | Q2_TOPOLOGY,
+			     HANDLER(cli_list_map_topology));
+	set_handler_callback(VRB_LIST | Q1_MAP | Q2_FMT, HANDLER(cli_list_map_fmt));
+	set_handler_callback(VRB_LIST | Q1_MAP | Q2_RAW | Q3_FMT,
+			     HANDLER(cli_list_map_fmt));
+	set_handler_callback(VRB_LIST | Q1_MAP | Q2_JSON, HANDLER(cli_list_map_json));
+	set_handler_callback(VRB_LIST | Q1_CONFIG | Q2_LOCAL,
+			     HANDLER(cli_list_config_local));
+	set_handler_callback(VRB_LIST | Q1_CONFIG, HANDLER(cli_list_config));
+	set_handler_callback(VRB_LIST | Q1_BLACKLIST, HANDLER(cli_list_blacklist));
+	set_handler_callback(VRB_LIST | Q1_DEVICES, HANDLER(cli_list_devices));
+	set_handler_callback(VRB_LIST | Q1_WILDCARDS, HANDLER(cli_list_wildcards));
+	set_handler_callback(VRB_RESET | Q1_MAPS | Q2_STATS,
+			     HANDLER(cli_reset_maps_stats));
+	set_handler_callback(VRB_RESET | Q1_MAP | Q2_STATS,
+			     HANDLER(cli_reset_map_stats));
+	set_handler_callback(VRB_ADD | Q1_PATH, HANDLER(cli_add_path));
+	set_handler_callback(VRB_DEL | Q1_PATH, HANDLER(cli_del_path));
+	set_handler_callback(VRB_ADD | Q1_MAP, HANDLER(cli_add_map));
+	set_handler_callback(VRB_DEL | Q1_MAP, HANDLER(cli_del_map));
+	set_handler_callback(VRB_DEL | Q1_MAPS, HANDLER(cli_del_maps));
+	set_handler_callback(VRB_SWITCH | Q1_MAP | Q2_GROUP, HANDLER(cli_switch_group));
+	set_unlocked_handler_callback(VRB_RECONFIGURE, HANDLER(cli_reconfigure));
+	set_unlocked_handler_callback(VRB_RECONFIGURE | Q1_ALL,
+				      HANDLER(cli_reconfigure_all));
+	set_handler_callback(VRB_SUSPEND | Q1_MAP, HANDLER(cli_suspend));
+	set_handler_callback(VRB_RESUME | Q1_MAP, HANDLER(cli_resume));
+	set_handler_callback(VRB_RESIZE | Q1_MAP, HANDLER(cli_resize));
+	set_handler_callback(VRB_RELOAD | Q1_MAP, HANDLER(cli_reload));
+	set_handler_callback(VRB_RESET | Q1_MAP, HANDLER(cli_reassign));
+	set_handler_callback(VRB_REINSTATE | Q1_PATH, HANDLER(cli_reinstate));
+	set_handler_callback(VRB_FAIL | Q1_PATH, HANDLER(cli_fail));
+	set_handler_callback(VRB_DISABLEQ | Q1_MAP, HANDLER(cli_disable_queueing));
+	set_handler_callback(VRB_RESTOREQ | Q1_MAP, HANDLER(cli_restore_queueing));
+	set_handler_callback(VRB_DISABLEQ | Q1_MAPS, HANDLER(cli_disable_all_queueing));
+	set_handler_callback(VRB_RESTOREQ | Q1_MAPS, HANDLER(cli_restore_all_queueing));
+	set_unlocked_handler_callback(VRB_QUIT, HANDLER(cli_quit));
+	set_unlocked_handler_callback(VRB_SHUTDOWN, HANDLER(cli_shutdown));
+	set_handler_callback(VRB_GETPRSTATUS | Q1_MAP, HANDLER(cli_getprstatus));
+	set_handler_callback(VRB_SETPRSTATUS | Q1_MAP, HANDLER(cli_setprstatus));
+	set_handler_callback(VRB_UNSETPRSTATUS | Q1_MAP, HANDLER(cli_unsetprstatus));
+	set_handler_callback(VRB_FORCEQ | Q1_DAEMON, HANDLER(cli_force_no_daemon_q));
+	set_handler_callback(VRB_RESTOREQ | Q1_DAEMON, HANDLER(cli_restore_no_daemon_q));
+	set_handler_callback(VRB_GETPRKEY | Q1_MAP, HANDLER(cli_getprkey));
+	set_handler_callback(VRB_SETPRKEY | Q1_MAP | Q2_KEY, HANDLER(cli_setprkey));
+	set_handler_callback(VRB_UNSETPRKEY | Q1_MAP, HANDLER(cli_unsetprkey));
+	set_handler_callback(VRB_SETMARGINAL | Q1_PATH, HANDLER(cli_set_marginal));
+	set_handler_callback(VRB_UNSETMARGINAL | Q1_PATH, HANDLER(cli_unset_marginal));
+	set_handler_callback(VRB_UNSETMARGINAL | Q1_MAP,
+			     HANDLER(cli_unset_all_marginal));
 }
diff --git a/multipathd/cli.c b/multipathd/cli.c
index 5d25ddb..96abd4d 100644
--- a/multipathd/cli.c
+++ b/multipathd/cli.c
@@ -30,6 +30,8 @@ vector get_handlers(void)
 {
 	return handlers;
 }
+/* See KEY_INVALID in cli.h */
+#define INVALID_FINGERPRINT ((uint32_t)(0))

 static struct key *
 alloc_key (void)
@@ -44,7 +46,7 @@ alloc_handler (void)
 }

 static int
-add_key (vector vec, char * str, uint64_t code, int has_param)
+add_key (vector vec, char * str, uint8_t code, int has_param)
 {
 	struct key * kw;

@@ -74,7 +76,7 @@ out:
 	return 1;
 }

-static struct handler *add_handler(uint64_t fp, cli_handler *fn, bool locked)
+static struct handler *add_handler(uint32_t fp, cli_handler *fn, bool locked)
 {
 	struct handler * h;

@@ -97,11 +99,13 @@ static struct handler *add_handler(uint64_t fp, cli_handler *fn, bool locked)
 }

 static struct handler *
-find_handler (uint64_t fp)
+find_handler (uint32_t fp)
 {
 	int i;
 	struct handler *h;

+	if (fp == INVALID_FINGERPRINT)
+		return NULL;
 	vector_foreach_slot (handlers, h, i)
 		if (h->fingerprint == fp)
 			return h;
@@ -110,14 +114,15 @@ find_handler (uint64_t fp)
 }

 int
-__set_handler_callback (uint64_t fp, cli_handler *fn, bool locked)
+__set_handler_callback (uint32_t fp, cli_handler *fn, bool locked)
 {
 	struct handler *h;

+	assert(fp != INVALID_FINGERPRINT);
 	assert(find_handler(fp) == NULL);
 	h = add_handler(fp, fn, locked);
 	if (!h) {
-		condlog(0, "%s: failed to set handler for code %"PRIu64,
+		condlog(0, "%s: failed to set handler for code %"PRIu32,
 			__func__, fp);
 		return 1;
 	}
@@ -170,56 +175,56 @@ load_keys (void)
 	if (!keys)
 		return 1;

-	r += add_key(keys, "list", LIST, 0);
-	r += add_key(keys, "show", LIST, 0);
-	r += add_key(keys, "add", ADD, 0);
-	r += add_key(keys, "remove", DEL, 0);
-	r += add_key(keys, "del", DEL, 0);
-	r += add_key(keys, "switch", SWITCH, 0);
-	r += add_key(keys, "switchgroup", SWITCH, 0);
-	r += add_key(keys, "suspend", SUSPEND, 0);
-	r += add_key(keys, "resume", RESUME, 0);
-	r += add_key(keys, "reinstate", REINSTATE, 0);
-	r += add_key(keys, "fail", FAIL, 0);
-	r += add_key(keys, "resize", RESIZE, 0);
-	r += add_key(keys, "reset", RESET, 0);
-	r += add_key(keys, "reload", RELOAD, 0);
-	r += add_key(keys, "forcequeueing", FORCEQ, 0);
-	r += add_key(keys, "disablequeueing", DISABLEQ, 0);
-	r += add_key(keys, "restorequeueing", RESTOREQ, 0);
-	r += add_key(keys, "paths", PATHS, 0);
-	r += add_key(keys, "maps", MAPS, 0);
-	r += add_key(keys, "multipaths", MAPS, 0);
-	r += add_key(keys, "path", PATH, 1);
-	r += add_key(keys, "map", MAP, 1);
-	r += add_key(keys, "multipath", MAP, 1);
-	r += add_key(keys, "group", GROUP, 1);
-	r += add_key(keys, "reconfigure", RECONFIGURE, 0);
-	r += add_key(keys, "daemon", DAEMON, 0);
-	r += add_key(keys, "status", STATUS, 0);
-	r += add_key(keys, "stats", STATS, 0);
-	r += add_key(keys, "topology", TOPOLOGY, 0);
-	r += add_key(keys, "config", CONFIG, 0);
-	r += add_key(keys, "blacklist", BLACKLIST, 0);
-	r += add_key(keys, "devices", DEVICES, 0);
-	r += add_key(keys, "raw", RAW, 0);
-	r += add_key(keys, "wildcards", WILDCARDS, 0);
-	r += add_key(keys, "quit", QUIT, 0);
-	r += add_key(keys, "exit", QUIT, 0);
-	r += add_key(keys, "shutdown", SHUTDOWN, 0);
-	r += add_key(keys, "getprstatus", GETPRSTATUS, 0);
-	r += add_key(keys, "setprstatus", SETPRSTATUS, 0);
-	r += add_key(keys, "unsetprstatus", UNSETPRSTATUS, 0);
-	r += add_key(keys, "format", FMT, 1);
-	r += add_key(keys, "json", JSON, 0);
-	r += add_key(keys, "getprkey", GETPRKEY, 0);
-	r += add_key(keys, "setprkey", SETPRKEY, 0);
-	r += add_key(keys, "unsetprkey", UNSETPRKEY, 0);
-	r += add_key(keys, "key", KEY, 1);
-	r += add_key(keys, "local", LOCAL, 0);
-	r += add_key(keys, "setmarginal", SETMARGINAL, 0);
-	r += add_key(keys, "unsetmarginal", UNSETMARGINAL, 0);
-	r += add_key(keys, "all", ALL, 0);
+	r += add_key(keys, "list", VRB_LIST, 0);
+	r += add_key(keys, "show", VRB_LIST, 0);
+	r += add_key(keys, "add", VRB_ADD, 0);
+	r += add_key(keys, "remove", VRB_DEL, 0);
+	r += add_key(keys, "del", VRB_DEL, 0);
+	r += add_key(keys, "switch", VRB_SWITCH, 0);
+	r += add_key(keys, "switchgroup", VRB_SWITCH, 0);
+	r += add_key(keys, "suspend", VRB_SUSPEND, 0);
+	r += add_key(keys, "resume", VRB_RESUME, 0);
+	r += add_key(keys, "reinstate", VRB_REINSTATE, 0);
+	r += add_key(keys, "fail", VRB_FAIL, 0);
+	r += add_key(keys, "resize", VRB_RESIZE, 0);
+	r += add_key(keys, "reset", VRB_RESET, 0);
+	r += add_key(keys, "reload", VRB_RELOAD, 0);
+	r += add_key(keys, "forcequeueing", VRB_FORCEQ, 0);
+	r += add_key(keys, "disablequeueing", VRB_DISABLEQ, 0);
+	r += add_key(keys, "restorequeueing", VRB_RESTOREQ, 0);
+	r += add_key(keys, "paths", KEY_PATHS, 0);
+	r += add_key(keys, "maps", KEY_MAPS, 0);
+	r += add_key(keys, "multipaths", KEY_MAPS, 0);
+	r += add_key(keys, "path", KEY_PATH, 1);
+	r += add_key(keys, "map", KEY_MAP, 1);
+	r += add_key(keys, "multipath", KEY_MAP, 1);
+	r += add_key(keys, "group", KEY_GROUP, 1);
+	r += add_key(keys, "reconfigure", VRB_RECONFIGURE, 0);
+	r += add_key(keys, "daemon", KEY_DAEMON, 0);
+	r += add_key(keys, "status", KEY_STATUS, 0);
+	r += add_key(keys, "stats", KEY_STATS, 0);
+	r += add_key(keys, "topology", KEY_TOPOLOGY, 0);
+	r += add_key(keys, "config", KEY_CONFIG, 0);
+	r += add_key(keys, "blacklist", KEY_BLACKLIST, 0);
+	r += add_key(keys, "devices", KEY_DEVICES, 0);
+	r += add_key(keys, "raw", KEY_RAW, 0);
+	r += add_key(keys, "wildcards", KEY_WILDCARDS, 0);
+	r += add_key(keys, "quit", VRB_QUIT, 0);
+	r += add_key(keys, "exit", VRB_QUIT, 0);
+	r += add_key(keys, "shutdown", VRB_SHUTDOWN, 0);
+	r += add_key(keys, "getprstatus", VRB_GETPRSTATUS, 0);
+	r += add_key(keys, "setprstatus", VRB_SETPRSTATUS, 0);
+	r += add_key(keys, "unsetprstatus", VRB_UNSETPRSTATUS, 0);
+	r += add_key(keys, "format", KEY_FMT, 1);
+	r += add_key(keys, "json", KEY_JSON, 0);
+	r += add_key(keys, "getprkey", VRB_GETPRKEY, 0);
+	r += add_key(keys, "setprkey", VRB_SETPRKEY, 0);
+	r += add_key(keys, "unsetprkey", VRB_UNSETPRKEY, 0);
+	r += add_key(keys, "key", KEY_KEY, 1);
+	r += add_key(keys, "local", KEY_LOCAL, 0);
+	r += add_key(keys, "setmarginal", VRB_SETMARGINAL, 0);
+	r += add_key(keys, "unsetmarginal", VRB_UNSETMARGINAL, 0);
+	r += add_key(keys, "all", KEY_ALL, 0);


 	if (r) {
@@ -327,18 +332,20 @@ out:
 	return r;
 }

-uint64_t fingerprint(const struct _vector *vec)
+uint32_t fingerprint(const struct _vector *vec)
 {
 	int i;
-	uint64_t fp = 0;
+	uint32_t fp = 0;
 	struct key * kw;

-	if (!vec)
-		return 0;
-
-	vector_foreach_slot(vec, kw, i)
-		fp += kw->code;
+	if (!vec || VECTOR_SIZE(vec) > 4)
+		return INVALID_FINGERPRINT;

+	vector_foreach_slot(vec, kw, i) {
+		if (i >= 4)
+			break;
+		fp |= (uint32_t)kw->code << (8 * i);
+	}
 	return fp;
 }

@@ -377,8 +384,8 @@ genhelp_sprint_aliases (struct strbuf *reply, vector keys,

 static int
 do_genhelp(struct strbuf *reply, const char *cmd, int error) {
-	int i, j;
-	uint64_t fp;
+	int i, j, k;
+	uint32_t fp;
 	struct handler * h;
 	struct key * kw;
 	int rc = 0;
@@ -404,17 +411,24 @@ do_genhelp(struct strbuf *reply, const char *cmd, int error) {

 	vector_foreach_slot (handlers, h, i) {
 		fp = h->fingerprint;
-		vector_foreach_slot (keys, kw, j) {
-			if ((kw->code & fp)) {
-				fp -= kw->code;
-				if (print_strbuf(reply, " %s", kw->str) < 0 ||
-				    genhelp_sprint_aliases(reply, keys, kw) < 0)
-					return -1;
+		for (k = 0; k < 4; k++, fp >>= 8) {
+			uint32_t code = fp & 0xff;

-				if (kw->has_param) {
-					if (print_strbuf(reply, " $%s",
-							 kw->str) < 0)
+			if (!code)
+				break;
+
+			vector_foreach_slot (keys, kw, j) {
+				if ((uint32_t)kw->code == code) {
+					if (print_strbuf(reply, " %s", kw->str) < 0 ||
+					    genhelp_sprint_aliases(reply, keys, kw) < 0)
 						return -1;
+
+					if (kw->has_param) {
+						if (print_strbuf(reply, " $%s",
+								 kw->str) < 0)
+							return -1;
+					}
+					break;
 				}
 			}
 		}
@@ -432,7 +446,7 @@ void genhelp_handler(const char *cmd, int error, struct strbuf *reply)
 }

 char *
-get_keyparam (vector v, uint64_t code)
+get_keyparam (vector v, uint8_t code)
 {
 	struct key * kw;
 	int i;
diff --git a/multipathd/cli.h b/multipathd/cli.h
index cb5bbe2..4de6b66 100644
--- a/multipathd/cli.h
+++ b/multipathd/cli.h
@@ -3,98 +3,98 @@

 #include <stdint.h>

+/*
+ * CLI commands consist of 4 bytes, a verb (byte 0) and up to
+ * 3 qualifiers (byte 1 - 3).
+ */
+
 enum {
-	__LIST,			/*  0 */
-	__ADD,
-	__DEL,
-	__SWITCH,
-	__SUSPEND,
-	__RESUME,			/*  5 */
-	__REINSTATE,
-	__FAIL,
-	__RESIZE,
-	__RESET,
-	__RELOAD,			/* 10 */
-	__FORCEQ,
-	__DISABLEQ,
-	__RESTOREQ,
-	__PATHS,
-	__MAPS,			/* 15 */
-	__PATH,
-	__MAP,
-	__GROUP,
-	__RECONFIGURE,
-	__DAEMON,			/* 20 */
-	__STATUS,
-	__STATS,
-	__TOPOLOGY,
-	__CONFIG,
-	__BLACKLIST,			/* 25 */
-	__DEVICES,
-	__RAW,
-	__WILDCARDS,
-	__QUIT,
-	__SHUTDOWN,			/* 30 */
-	__GETPRSTATUS,
-	__SETPRSTATUS,
-	__UNSETPRSTATUS,
-	__FMT,
-	__JSON,			/* 35 */
-	__GETPRKEY,
-	__SETPRKEY,
-	__UNSETPRKEY,
-	__KEY,
-	__LOCAL,			/* 40 */
-	__SETMARGINAL,
-	__UNSETMARGINAL,
-	__ALL,
+	/* See INVALID_FINGERPRINT in cli.c */
+	KEY_INVALID		=  0,
+
+	/* Verbs */
+	VRB_LIST		=  1,
+	VRB_ADD			=  2,
+	VRB_DEL			=  3,
+	VRB_RESET		=  4,
+	VRB_SWITCH		=  5,
+	VRB_RECONFIGURE		=  6,
+	VRB_SUSPEND		=  7,
+	VRB_RESUME		=  8,
+	VRB_RESIZE		=  9,
+	VRB_RELOAD		= 10,
+	VRB_FAIL		= 11,
+	VRB_REINSTATE		= 12,
+	VRB_DISABLEQ		= 13,
+	VRB_RESTOREQ		= 14,
+	VRB_FORCEQ		= 15,
+	VRB_GETPRSTATUS		= 16,
+	VRB_SETPRSTATUS		= 17,
+	VRB_UNSETPRSTATUS	= 18,
+	VRB_GETPRKEY		= 19,
+	VRB_SETPRKEY		= 20,
+	VRB_UNSETPRKEY		= 21,
+	VRB_SETMARGINAL		= 22,
+	VRB_UNSETMARGINAL	= 23,
+	VRB_SHUTDOWN		= 24,
+	VRB_QUIT		= 25,
+
+	/* Qualifiers, values must be different from verbs */
+	KEY_PATH		= 65,
+	KEY_PATHS		= 66,
+	KEY_MAP			= 67,
+	KEY_MAPS		= 68,
+	KEY_TOPOLOGY		= 69,
+	KEY_CONFIG		= 70,
+	KEY_BLACKLIST		= 71,
+	KEY_DEVICES		= 72,
+	KEY_WILDCARDS		= 73,
+	KEY_ALL			= 74,
+	KEY_DAEMON		= 75,
+	KEY_FMT			= 76,
+	KEY_RAW			= 77,
+	KEY_STATUS		= 78,
+	KEY_STATS		= 79,
+	KEY_JSON		= 80,
+	KEY_LOCAL		= 81,
+	KEY_GROUP		= 82,
+	KEY_KEY			= 83,
 };

-#define LIST		(1ULL << __LIST)
-#define ADD		(1ULL << __ADD)
-#define DEL		(1ULL << __DEL)
-#define SWITCH		(1ULL << __SWITCH)
-#define SUSPEND	(1ULL << __SUSPEND)
-#define RESUME		(1ULL << __RESUME)
-#define REINSTATE	(1ULL << __REINSTATE)
-#define FAIL		(1ULL << __FAIL)
-#define RESIZE		(1ULL << __RESIZE)
-#define RESET		(1ULL << __RESET)
-#define RELOAD		(1ULL << __RELOAD)
-#define FORCEQ		(1ULL << __FORCEQ)
-#define DISABLEQ	(1ULL << __DISABLEQ)
-#define RESTOREQ	(1ULL << __RESTOREQ)
-#define PATHS		(1ULL << __PATHS)
-#define MAPS		(1ULL << __MAPS)
-#define PATH		(1ULL << __PATH)
-#define MAP		(1ULL << __MAP)
-#define GROUP		(1ULL << __GROUP)
-#define RECONFIGURE	(1ULL << __RECONFIGURE)
-#define DAEMON		(1ULL << __DAEMON)
-#define STATUS		(1ULL << __STATUS)
-#define STATS		(1ULL << __STATS)
-#define TOPOLOGY	(1ULL << __TOPOLOGY)
-#define CONFIG		(1ULL << __CONFIG)
-#define BLACKLIST	(1ULL << __BLACKLIST)
-#define DEVICES	(1ULL << __DEVICES)
-#define RAW		(1ULL << __RAW)
-#define COUNT		(1ULL << __COUNT)
-#define WILDCARDS	(1ULL << __WILDCARDS)
-#define QUIT		(1ULL << __QUIT)
-#define SHUTDOWN	(1ULL << __SHUTDOWN)
-#define GETPRSTATUS	(1ULL << __GETPRSTATUS)
-#define SETPRSTATUS	(1ULL << __SETPRSTATUS)
-#define UNSETPRSTATUS	(1ULL << __UNSETPRSTATUS)
-#define FMT		(1ULL << __FMT)
-#define JSON		(1ULL << __JSON)
-#define GETPRKEY	(1ULL << __GETPRKEY)
-#define SETPRKEY	(1ULL << __SETPRKEY)
-#define UNSETPRKEY	(1ULL << __UNSETPRKEY)
-#define KEY		(1ULL << __KEY)
-#define LOCAL		(1ULL << __LOCAL)
-#define SETMARGINAL	(1ULL << __SETMARGINAL)
-#define UNSETMARGINAL	(1ULL << __UNSETMARGINAL)
-#define ALL		(1ULL << __ALL)
+/*
+ * The shifted qualifiers determine valid positions of the
+ * keywords in the known commands. E.g. the only qualifier
+ * that's valid in position 3 is "fmt", e.g. "list maps raw fmt".
+ */
+enum {
+	/* byte 1: qualifier 1 */
+	Q1_PATH			= KEY_PATH << 8,
+	Q1_PATHS		= KEY_PATHS << 8,
+	Q1_MAP			= KEY_MAP << 8,
+	Q1_MAPS			= KEY_MAPS << 8,
+	Q1_TOPOLOGY		= KEY_TOPOLOGY << 8,
+	Q1_CONFIG		= KEY_CONFIG << 8,
+	Q1_BLACKLIST		= KEY_BLACKLIST << 8,
+	Q1_DEVICES		= KEY_DEVICES << 8,
+	Q1_WILDCARDS		= KEY_WILDCARDS << 8,
+	Q1_ALL			= KEY_ALL << 8,
+	Q1_DAEMON		= KEY_DAEMON << 8,
+	Q1_STATUS		= KEY_STATUS << 8,
+
+	/* byte 2: qualifier 2 */
+	Q2_FMT			= KEY_FMT << 16,
+	Q2_RAW			= KEY_RAW << 16,
+	Q2_STATUS		= KEY_STATUS << 16,
+	Q2_STATS		= KEY_STATS << 16,
+	Q2_TOPOLOGY		= KEY_TOPOLOGY << 16,
+	Q2_JSON			= KEY_JSON << 16,
+	Q2_LOCAL		= KEY_LOCAL << 16,
+	Q2_GROUP		= KEY_GROUP << 16,
+	Q2_KEY			= KEY_KEY << 16,
+
+	/* byte 3: qualifier 3 */
+	Q3_FMT			= KEY_FMT << 24,
+};

 #define INITIAL_REPLY_LEN	1200

@@ -122,7 +122,7 @@ enum {
 struct key {
 	char * str;
 	char * param;
-	uint64_t code;
+	uint8_t code;
 	int has_param;
 };

@@ -131,13 +131,13 @@ struct strbuf;
 typedef int (cli_handler)(void *keywords, struct strbuf *reply, void *data);

 struct handler {
-	uint64_t fingerprint;
+	uint32_t fingerprint;
 	int locked;
 	cli_handler *fn;
 };

 int alloc_handlers (void);
-int __set_handler_callback (uint64_t fp, cli_handler *fn, bool locked);
+int __set_handler_callback (uint32_t fp, cli_handler *fn, bool locked);
 #define set_handler_callback(fp, fn) __set_handler_callback(fp, fn, true)
 #define set_unlocked_handler_callback(fp, fn) __set_handler_callback(fp, fn, false)

@@ -146,12 +146,12 @@ struct handler *find_handler_for_cmdvec(const struct _vector *v);
 void genhelp_handler (const char *cmd, int error, struct strbuf *reply);

 int load_keys (void);
-char * get_keyparam (vector v, uint64_t code);
+char * get_keyparam (vector v, uint8_t code);
 void free_keys (vector vec);
 void free_handlers (void);
 int cli_init (void);
 void cli_exit(void);
-uint64_t fingerprint(const struct _vector *vec);
+uint32_t fingerprint(const struct _vector *vec);
 vector get_keys(void);
 vector get_handlers(void);
 struct key *find_key (const char * str);
diff --git a/multipathd/cli_handlers.c b/multipathd/cli_handlers.c
index 5b8f647..5f0dd04 100644
--- a/multipathd/cli_handlers.c
+++ b/multipathd/cli_handlers.c
@@ -217,7 +217,7 @@ static int
 cli_list_paths_fmt (void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * fmt = get_keyparam(v, FMT);
+	char * fmt = get_keyparam(v, KEY_FMT);

 	condlog(3, "list paths (operator)");

@@ -228,7 +228,7 @@ static int
 cli_list_paths_raw (void *v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * fmt = get_keyparam(v, FMT);
+	char * fmt = get_keyparam(v, KEY_FMT);

 	condlog(3, "list paths (operator)");

@@ -239,7 +239,7 @@ static int
 cli_list_path (void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path *pp;

 	param = convert_dev(param, 1);
@@ -257,7 +257,7 @@ cli_list_map_topology (void *v, struct strbuf *reply, void *data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);
 	fieldwidth_t *p_width __attribute__((cleanup(cleanup_ucharp))) = NULL;

 	if ((p_width = alloc_path_layout()) == NULL)
@@ -289,7 +289,7 @@ cli_list_map_json (void *v, struct strbuf *reply, void *data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);

 	param = convert_dev(param, 0);
 	mpp = find_mp_by_str(vecs->mpvec, param);
@@ -391,7 +391,7 @@ static int
 cli_list_maps_fmt (void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * fmt = get_keyparam(v, FMT);
+	char * fmt = get_keyparam(v, KEY_FMT);

 	condlog(3, "list maps (operator)");

@@ -402,7 +402,7 @@ static int
 cli_list_maps_raw (void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * fmt = get_keyparam(v, FMT);
+	char * fmt = get_keyparam(v, KEY_FMT);

 	condlog(3, "list maps (operator)");

@@ -414,8 +414,8 @@ cli_list_map_fmt (void *v, struct strbuf *reply, void *data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
-	char * fmt = get_keyparam(v, FMT);
+	char * param = get_keyparam(v, KEY_MAP);
+	char * fmt = get_keyparam(v, KEY_FMT);
 	fieldwidth_t *width __attribute__((cleanup(cleanup_ucharp))) = NULL;

 	if ((width = alloc_multipath_layout()) == NULL)
@@ -499,7 +499,7 @@ cli_reset_map_stats (void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
 	struct multipath * mpp;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);

 	param = convert_dev(param, 0);
 	mpp = find_mp_by_str(vecs->mpvec, param);
@@ -543,7 +543,7 @@ static int
 cli_add_path (void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path *pp;
 	int r;
 	struct config *conf;
@@ -663,7 +663,7 @@ static int
 cli_del_path (void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path *pp;
 	int ret;

@@ -686,7 +686,7 @@ static int
 cli_add_map (void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);
 	int major = -1, minor = -1;
 	char dev_path[FILE_NAME_SIZE];
 	char *refwwid, *alias = NULL;
@@ -746,7 +746,7 @@ static int
 cli_del_map (void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);
 	int major, minor;
 	char *alias;
 	int rc;
@@ -794,7 +794,7 @@ static int
 cli_reload(void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * mapname = get_keyparam(v, MAP);
+	char * mapname = get_keyparam(v, KEY_MAP);
 	struct multipath *mpp;
 	int minor;

@@ -847,7 +847,7 @@ static int
 cli_resize(void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * mapname = get_keyparam(v, MAP);
+	char * mapname = get_keyparam(v, KEY_MAP);
 	struct multipath *mpp;
 	int minor;
 	unsigned long long size;
@@ -938,7 +938,7 @@ static int
 cli_restore_queueing(void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * mapname = get_keyparam(v, MAP);
+	char * mapname = get_keyparam(v, KEY_MAP);
 	struct multipath *mpp;
 	int minor;
 	struct config *conf;
@@ -1001,7 +1001,7 @@ static int
 cli_disable_queueing(void *v, struct strbuf *reply, void *data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * mapname = get_keyparam(v, MAP);
+	char * mapname = get_keyparam(v, KEY_MAP);
 	struct multipath *mpp;
 	int minor;

@@ -1048,8 +1048,8 @@ cli_disable_all_queueing(void *v, struct strbuf *reply, void *data)
 static int
 cli_switch_group(void * v, struct strbuf *reply, void * data)
 {
-	char * mapname = get_keyparam(v, MAP);
-	int groupnum = atoi(get_keyparam(v, GROUP));
+	char * mapname = get_keyparam(v, KEY_MAP);
+	int groupnum = atoi(get_keyparam(v, KEY_GROUP));

 	mapname = convert_dev(mapname, 0);
 	condlog(2, "%s: switch to path group #%i (operator)", mapname, groupnum);
@@ -1079,7 +1079,7 @@ static int
 cli_suspend(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);
 	int r;
 	struct multipath * mpp;

@@ -1109,7 +1109,7 @@ static int
 cli_resume(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);
 	int r;
 	struct multipath * mpp;
 	uint16_t udev_flags;
@@ -1141,7 +1141,7 @@ static int
 cli_reinstate(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path * pp;

 	param = convert_dev(param, 1);
@@ -1164,7 +1164,7 @@ static int
 cli_reassign (void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);
 	struct multipath *mpp;

 	param = convert_dev(param, 0);
@@ -1188,7 +1188,7 @@ static int
 cli_fail(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path * pp;
 	int r;

@@ -1284,7 +1284,7 @@ cli_getprstatus (void * v, struct strbuf *reply, void * data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);

 	param = convert_dev(param, 0);
 	mpp = find_mp_by_str(vecs->mpvec, param);
@@ -1307,7 +1307,7 @@ cli_setprstatus(void * v, struct strbuf *reply, void * data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);

 	param = convert_dev(param, 0);
 	mpp = find_mp_by_str(vecs->mpvec, param);
@@ -1329,7 +1329,7 @@ cli_unsetprstatus(void * v, struct strbuf *reply, void * data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, MAP);
+	char * param = get_keyparam(v, KEY_MAP);

 	param = convert_dev(param, 0);
 	mpp = find_mp_by_str(vecs->mpvec, param);
@@ -1350,7 +1350,7 @@ cli_getprkey(void * v, struct strbuf *reply, void * data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char *mapname = get_keyparam(v, MAP);
+	char *mapname = get_keyparam(v, KEY_MAP);
 	uint64_t key;

 	mapname = convert_dev(mapname, 0);
@@ -1377,7 +1377,7 @@ cli_unsetprkey(void * v, struct strbuf *reply, void * data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char *mapname = get_keyparam(v, MAP);
+	char *mapname = get_keyparam(v, KEY_MAP);
 	int ret;
 	struct config *conf;

@@ -1401,8 +1401,8 @@ cli_setprkey(void * v, struct strbuf *reply, void * data)
 {
 	struct multipath * mpp;
 	struct vectors * vecs = (struct vectors *)data;
-	char *mapname = get_keyparam(v, MAP);
-	char *keyparam = get_keyparam(v, KEY);
+	char *mapname = get_keyparam(v, KEY_MAP);
+	char *keyparam = get_keyparam(v, KEY_KEY);
 	uint64_t prkey;
 	uint8_t flags;
 	int ret;
@@ -1431,7 +1431,7 @@ cli_setprkey(void * v, struct strbuf *reply, void * data)
 static int cli_set_marginal(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path * pp;

 	param = convert_dev(param, 1);
@@ -1458,7 +1458,7 @@ static int cli_set_marginal(void * v, struct strbuf *reply, void * data)
 static int cli_unset_marginal(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * param = get_keyparam(v, PATH);
+	char * param = get_keyparam(v, KEY_PATH);
 	struct path * pp;

 	param = convert_dev(param, 1);
@@ -1485,7 +1485,7 @@ static int cli_unset_marginal(void * v, struct strbuf *reply, void * data)
 static int cli_unset_all_marginal(void * v, struct strbuf *reply, void * data)
 {
 	struct vectors * vecs = (struct vectors *)data;
-	char * mapname = get_keyparam(v, MAP);
+	char * mapname = get_keyparam(v, KEY_MAP);
 	struct multipath *mpp;
 	struct pathgroup * pgp;
 	struct path * pp;
diff --git a/multipathd/multipathc.c b/multipathd/multipathc.c
index b3f7db0..562f1da 100644
--- a/multipathd/multipathc.c
+++ b/multipathd/multipathc.c
@@ -40,7 +40,7 @@

 #if defined(USE_LIBREADLINE) || defined(USE_LIBEDIT)
 static int
-key_match_fingerprint (struct key * kw, uint64_t fp)
+key_match_fingerprint (struct key * kw, uint32_t fp)
 {
 	if (!fp)
 		return 0;
@@ -55,7 +55,7 @@ char *
 key_generator (const char * str, int state)
 {
 	static int index, len, has_param;
-	static uint64_t rlfp;
+	static uint32_t rlfp;
 	struct key * kw;
 	int i;
 	struct handler *h;
@@ -127,7 +127,7 @@ key_generator (const char * str, int state)
 			 * nfp is the candidate fingerprint we try to
 			 * validate against all known command fingerprints.
 			 */
-			uint64_t nfp = rlfp | kw->code;
+			uint32_t nfp = rlfp | kw->code;
 			vector_foreach_slot(handlers, h, i) {
 				if (!rlfp || ((h->fingerprint & nfp) == nfp)) {
 					/*
diff --git a/multipathd/uxlsnr.c b/multipathd/uxlsnr.c
index 238744b..3165492 100644
--- a/multipathd/uxlsnr.c
+++ b/multipathd/uxlsnr.c
@@ -484,7 +484,7 @@ static int client_state_machine(struct client *c, struct vectors *vecs,
 			/* Permission check */
 			struct key *kw = VECTOR_SLOT(c->cmdvec, 0);

-			if (!c->is_root && kw->code != LIST) {
+			if (!c->is_root && kw->code != VRB_LIST) {
 				c->error = -EPERM;
 				condlog(0, "%s: cli[%d]: unauthorized cmd \"%s\"",
 					__func__, c->fd, c->cmd);
--
2.37.2


From MAILER-DAEMON Tue Sep 27 19:37:20 2022
>From d139bcf0842bc0a16beab86e1349ed65b150bf0c Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@suse.com>
Date: Thu, 25 Aug 2022 12:40:24 +0200
Subject: [PATCH v5 2/5] multipathd: fix command completion with robust parser

The command completion must look at possible combinations of
keywords now. This makes it much more useful, actually.

Signed-off-by: Martin Wilck <mwilck@suse.com>
Reviewed-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 multipathd/cli.c        |  59 +++++++------
 multipathd/cli.h        |   3 +-
 multipathd/multipathc.c | 185 +++++++++++++++++++++++++---------------
 multipathd/uxlsnr.c     |   2 +-
 4 files changed, 149 insertions(+), 100 deletions(-)

diff --git a/multipathd/cli.c b/multipathd/cli.c
index 96abd4d..0c89b7c 100644
--- a/multipathd/cli.c
+++ b/multipathd/cli.c
@@ -129,8 +129,7 @@ __set_handler_callback (uint32_t fp, cli_handler *fn, bool locked)
 	return 0;
 }

-static void
-free_key (struct key * kw)
+void free_key (struct key * kw)
 {
 	if (kw->str)
 		free(kw->str);
@@ -260,15 +259,29 @@ struct key *find_key (const char * str)
 	return foundkw;
 }

+static void cleanup_strvec(vector *arg)
+{
+	free_strvec(*arg);
+}
+
+static void cleanup_keys(vector *arg)
+{
+	free_keys(*arg);
+}
+
 /*
- * get_cmdvec
+ * get_cmdvec() - parse input
+ *
+ * @cmd: a command string to be parsed
+ * @v: a vector of keywords with parameters
  *
  * returns:
  * ENOMEM: not enough memory to allocate command
- * ESRCH: command not found
+ * ESRCH: keyword not found at end of input
+ * ENOENT: keyword not found somewhere else
  * EINVAL: argument missing for command
  */
-int get_cmdvec (char *cmd, vector *v)
+int get_cmdvec (char *cmd, vector *v, bool allow_incomplete)
 {
 	int i;
 	int r = 0;
@@ -276,19 +289,12 @@ int get_cmdvec (char *cmd, vector *v)
 	char * buff;
 	struct key * kw = NULL;
 	struct key * cmdkw = NULL;
-	vector cmdvec, strvec;
+	vector cmdvec __attribute__((cleanup(cleanup_keys))) = vector_alloc();
+	vector strvec __attribute__((cleanup(cleanup_strvec))) = alloc_strvec(cmd);

-	strvec = alloc_strvec(cmd);
-	if (!strvec)
+	if (!strvec || !cmdvec)
 		return ENOMEM;

-	cmdvec = vector_alloc();
-
-	if (!cmdvec) {
-		free_strvec(strvec);
-		return ENOMEM;
-	}
-
 	vector_foreach_slot(strvec, buff, i) {
 		if (is_quote(buff))
 			continue;
@@ -299,18 +305,18 @@ int get_cmdvec (char *cmd, vector *v)
 		}
 		kw = find_key(buff);
 		if (!kw) {
-			r = ESRCH;
-			goto out;
+			r = i == VECTOR_SIZE(strvec) - 1 ? ESRCH : ENOENT;
+			break;
 		}
 		cmdkw = alloc_key();
 		if (!cmdkw) {
 			r = ENOMEM;
-			goto out;
+			break;
 		}
 		if (!vector_alloc_slot(cmdvec)) {
 			free(cmdkw);
 			r = ENOMEM;
-			goto out;
+			break;
 		}
 		vector_set_slot(cmdvec, cmdkw);
 		cmdkw->code = kw->code;
@@ -318,17 +324,14 @@ int get_cmdvec (char *cmd, vector *v)
 		if (kw->has_param)
 			get_param = 1;
 	}
-	if (get_param) {
+	if (get_param)
 		r = EINVAL;
-		goto out;
-	}
-	*v = cmdvec;
-	free_strvec(strvec);
-	return 0;

-out:
-	free_strvec(strvec);
-	free_keys(cmdvec);
+	if (r && !allow_incomplete)
+		return r;
+
+	*v = cmdvec;
+	cmdvec = NULL;
 	return r;
 }

diff --git a/multipathd/cli.h b/multipathd/cli.h
index 4de6b66..c6b79c9 100644
--- a/multipathd/cli.h
+++ b/multipathd/cli.h
@@ -141,12 +141,13 @@ int __set_handler_callback (uint32_t fp, cli_handler *fn, bool locked);
 #define set_handler_callback(fp, fn) __set_handler_callback(fp, fn, true)
 #define set_unlocked_handler_callback(fp, fn) __set_handler_callback(fp, fn, false)

-int get_cmdvec (char *cmd, vector *v);
+int get_cmdvec (char *cmd, vector *v, bool allow_incomplete);
 struct handler *find_handler_for_cmdvec(const struct _vector *v);
 void genhelp_handler (const char *cmd, int error, struct strbuf *reply);

 int load_keys (void);
 char * get_keyparam (vector v, uint8_t code);
+void free_key (struct key * kw);
 void free_keys (vector vec);
 void free_handlers (void);
 int cli_init (void);
diff --git a/multipathd/multipathc.c b/multipathd/multipathc.c
index 562f1da..38f2d6a 100644
--- a/multipathd/multipathc.c
+++ b/multipathd/multipathc.c
@@ -15,6 +15,7 @@
 #include "uxsock.h"
 #include "util.h"
 #include "cli.h"
+#include "debug.h"

 #ifdef USE_LIBEDIT
 #include <editline/readline.h>
@@ -39,44 +40,68 @@
 #endif

 #if defined(USE_LIBREADLINE) || defined(USE_LIBEDIT)
-static int
-key_match_fingerprint (struct key * kw, uint32_t fp)
-{
-	if (!fp)
-		return 0;
-
-	return ((fp & kw->code) == kw->code);
-}
-
 /*
  * This is the readline completion handler
  */
 char *
 key_generator (const char * str, int state)
 {
-	static int index, len, has_param;
-	static uint32_t rlfp;
-	struct key * kw;
-	int i;
-	struct handler *h;
-	vector v = NULL;
-	const vector keys = get_keys();
-	const vector handlers = get_handlers();
+	static vector completions;
+	static int index;
+	char *word;

 	if (!state) {
+		uint32_t rlfp = 0, mask = 0;
+		int len = strlen(str), vlen = 0, i, j;
+		struct key * kw;
+		struct handler *h;
+		vector handlers = get_handlers();
+		vector keys = get_keys();
+		vector v = NULL;
+		int r = get_cmdvec(rl_line_buffer, &v, true);
+
 		index = 0;
-		has_param = 0;
-		rlfp = 0;
-		len = strlen(str);
-		int r = get_cmdvec(rl_line_buffer, &v);
+		if (completions)
+			vector_free(completions);
+
+		completions = vector_alloc();
+
+		if (!completions || r == ENOMEM) {
+			if (v)
+				vector_free(v);
+			return NULL;
+		}
+
+		/*
+		 * Special case: get_cmdvec() ignores trailing whitespace,
+		 * readline doesn't. get_cmdvec() will return "[show]" and
+		 * ESRCH for both "show bogus\t" and "show bogus \t".
+		 * The former case will fail below. In the latter case,
+		 * We shouldn't offer completions.
+		 */
+		if (r == ESRCH && !len)
+			r = ENOENT;
+
 		/*
 		 * If a word completion is in progress, we don't want
 		 * to take an exact keyword match in the fingerprint.
 		 * For ex "show map[tab]" would validate "map" and discard
 		 * "maps" as a valid candidate.
 		 */
-		if (v && len)
-			vector_del_slot(v, VECTOR_SIZE(v) - 1);
+		if (r != ESRCH && VECTOR_SIZE(v) && len) {
+			kw = VECTOR_SLOT(v, VECTOR_SIZE(v) - 1);
+			/*
+			 * If kw->param is set, we were already parsing a
+			 * parameter, not the keyword. Don't delete it.
+			 */
+			if (!kw->param) {
+				free_key(kw);
+				vector_del_slot(v, VECTOR_SIZE(v) - 1);
+				if (r == EINVAL)
+					r = 0;
+			}
+		}
+
 		/*
 		 * Clean up the mess if we dropped the last slot of a 1-slot
 		 * vector
@@ -85,66 +110,86 @@ key_generator (const char * str, int state)
 			vector_free(v);
 			v = NULL;
 		}
-		/*
-		 * If last keyword takes a param, don't even try to guess
-		 */
-		if (r == EINVAL) {
-			has_param = 1;
-			return (strdup("(value)"));
-		}
+
 		/*
 		 * Compute a command fingerprint to find out possible completions.
 		 * Once done, the vector is useless. Free it.
 		 */
 		if (v) {
 			rlfp = fingerprint(v);
+			vlen = VECTOR_SIZE(v);
+			if (vlen >= 4)
+				mask = ~0;
+			else
+				mask = (uint32_t)(1U << (8 * vlen)) - 1;
 			free_keys(v);
 		}
-	}
-	/*
-	 * No more completions for parameter placeholder.
-	 * Brave souls might try to add parameter completion by walking paths and
-	 * multipaths vectors.
-	 */
-	if (has_param)
-		return ((char *)NULL);
-	/*
-	 * Loop through keywords for completion candidates
-	 */
-	vector_foreach_slot_after (keys, kw, index) {
-		if (!strncmp(kw->str, str, len)) {
-			/*
-			 * Discard keywords already in the command line
-			 */
-			if (key_match_fingerprint(kw, rlfp)) {
-				struct key * curkw = find_key(str);
-				if (!curkw || (curkw != kw))
+		condlog(4, "%s: line=\"%s\" str=\"%s\" r=%d fp=%08x mask=%08x",
+			__func__, rl_line_buffer, str, r, rlfp, mask);
+
+		/*
+		 * If last keyword takes a param, don't even try to guess
+		 * Brave souls might try to add parameter completion by walking
+		 * paths and multipaths vectors.
+		 */
+		if (r == EINVAL) {
+			if (len == 0 && vector_alloc_slot(completions))
+				vector_set_slot(completions,
+						strdup("VALUE"));
+
+			goto init_done;
+		}
+
+		if (r == ENOENT)
+			goto init_done;
+
+		vector_foreach_slot(handlers, h, i) {
+			uint8_t code;
+
+			if (rlfp != (h->fingerprint & mask))
+				continue;
+
+			if (vlen >= 4)
+				/*
+				 * => mask == ~0 => rlfp == h->fingerprint
+				 * Complete command. This must be the only match.
+				 */
+				goto init_done;
+			else if (rlfp == h->fingerprint && r != ESRCH &&
+				 !strcmp(str, "") &&
+				 vector_alloc_slot(completions))
+				/* just completed */
+				vector_set_slot(completions, strdup(""));
+			else {
+				/* vlen must be 1, 2, or 3 */
+				code = (h->fingerprint >> vlen * 8);
+
+				if (code == KEY_INVALID)
 					continue;
-			}
-			/*
-			 * Discard keywords making syntax errors.
-			 *
-			 * nfp is the candidate fingerprint we try to
-			 * validate against all known command fingerprints.
-			 */
-			uint32_t nfp = rlfp | kw->code;
-			vector_foreach_slot(handlers, h, i) {
-				if (!rlfp || ((h->fingerprint & nfp) == nfp)) {
-					/*
-					 * At least one full command is
-					 * possible with this keyword :
-					 * Consider it validated
-					 */
-					index++;
-					return (strdup(kw->str));
+
+				vector_foreach_slot(keys, kw, j) {
+					if (kw->code != code ||
+					    strncmp(kw->str, str, len))
+						continue;
+					if (vector_alloc_slot(completions))
+						vector_set_slot(completions,
+								strdup(kw->str));
 				}
 			}
+
 		}
+		vector_foreach_slot(completions, word, i)
+			condlog(4, "%s: %d -> \"%s\"", __func__, i, word);
+
 	}
-	/*
-	 * No more candidates
-	 */
-	return ((char *)NULL);
+
+init_done:
+	vector_foreach_slot_after(completions, word, index) {
+		index++;
+		return word;
+	}
+
+	return NULL;
 }
 #endif

diff --git a/multipathd/uxlsnr.c b/multipathd/uxlsnr.c
index 3165492..91b9079 100644
--- a/multipathd/uxlsnr.c
+++ b/multipathd/uxlsnr.c
@@ -332,7 +332,7 @@ static int parse_cmd(struct client *c)
 {
 	int r;

-	r = get_cmdvec(c->cmd, &c->cmdvec);
+	r = get_cmdvec(c->cmd, &c->cmdvec, false);

 	if (r)
 		return -r;
--
2.37.2


From MAILER-DAEMON Tue Sep 27 19:37:20 2022
>From 2a1ff3154c1d5de423c303ca3bc9ed9727b4e523 Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@suse.com>
Date: Thu, 1 Sep 2022 23:15:13 +0200
Subject: [PATCH v5 3/5] multipath-tools tests: add test for command parsing

Add tests for parsing multipathd interactive commands.

Signed-off-by: Martin Wilck <mwilck@suse.com>
Reviewed-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 Makefile.inc   |   1 +
 tests/Makefile |   6 +-
 tests/cli.c    | 237 +++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 242 insertions(+), 2 deletions(-)
 create mode 100644 tests/cli.c

diff --git a/Makefile.inc b/Makefile.inc
index 6399beb..50472c0 100644
--- a/Makefile.inc
+++ b/Makefile.inc
@@ -86,6 +86,7 @@ libudevdir	= $(prefix)/$(SYSTEMDPATH)/udev
 udevrulesdir	= $(libudevdir)/rules.d
 modulesloaddir  = $(prefix)/$(SYSTEMDPATH)/modules-load.d
 multipathdir	= $(TOPDIR)/libmultipath
+daemondir       = $(TOPDIR)/multipathd
 mpathutildir	= $(TOPDIR)/libmpathutil
 man8dir		= $(prefix)/usr/share/man/man8
 man5dir		= $(prefix)/usr/share/man/man5
diff --git a/tests/Makefile b/tests/Makefile
index 109ea75..b26a348 100644
--- a/tests/Makefile
+++ b/tests/Makefile
@@ -11,12 +11,13 @@ TEST_MISSING_INITIALIZERS = $(shell \
 	|| echo -Wno-missing-field-initializers)
 W_MISSING_INITIALIZERS := $(call TEST_MISSING_INITIALIZERS)

-CPPFLAGS += -I$(multipathdir) -I$(mpathutildir) -I$(mpathcmddir) -DTESTCONFDIR=\"$(TESTDIR)/conf.d\"
+CPPFLAGS += -I$(multipathdir) -I$(mpathutildir) -I$(mpathcmddir) -I$(daemondir) \
+	-DTESTCONFDIR=\"$(TESTDIR)/conf.d\"
 CFLAGS += $(BIN_CFLAGS) -Wno-unused-parameter $(W_MISSING_INITIALIZERS)
 LIBDEPS += -L. -L $(mpathutildir) -L$(mpathcmddir) -lmultipath -lmpathutil -lmpathcmd -lcmocka

 TESTS := uevent parser util dmevents hwtable blacklist unaligned vpd pgpolicy \
-	 alias directio valid devt mpathvalid strbuf sysfs
+	 alias directio valid devt mpathvalid strbuf sysfs cli
 HELPERS := test-lib.o test-log.o

 .SILENT: $(TESTS:%=%.o)
@@ -73,6 +74,7 @@ strbuf-test_OBJDEPS := $(mpathutildir)/strbuf.o
 sysfs-test_TESTDEPS := test-log.o
 sysfs-test_OBJDEPS := $(multipathdir)/sysfs.o $(mpathutildir)/util.o
 sysfs-test_LIBDEPS := -ludev -lpthread -ldl
+cli-test_OBJDEPS := $(daemondir)/cli.o

 %.o: %.c
 	$(CC) $(CPPFLAGS) $(CFLAGS) $($*-test_FLAGS) -c -o $@ $<
diff --git a/tests/cli.c b/tests/cli.c
new file mode 100644
index 0000000..9e2ad3c
--- /dev/null
+++ b/tests/cli.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright (c) 2020 Martin Wilck, SUSE
+ *
+ * SPDX-License-Identifier: GPL-2.0-or-later
+ */
+#include <stdbool.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <setjmp.h>
+#include <stdlib.h>
+#include <cmocka.h>
+
+#include <errno.h>
+
+#include "vector.h"
+#include "cli.h"
+
+#include "globals.c"
+#define HANDLER(x) NULL
+#include "callbacks.c"
+
+/* See cli.c */
+#define INVALID_FINGERPRINT ((uint32_t)(0))
+
+static int setup(void **state)
+{
+	return cli_init();
+}
+
+static int teardown(void **state)
+{
+	cli_exit();
+	return 0;
+}
+
+/*
+ * @NAME: test name
+ * @CMD: test command
+ * @R: retcode of get_cmdvec()
+ * @FPR: fingerprint (only if R==0)
+ * @GOOD: expect to find handler (only if R==0)
+ */
+#define client_test(NAME, CMD, R, FPR, GOOD)			\
+static void client_test_##NAME(void **state)			\
+{								\
+	vector v = NULL;					\
+	char cmd[] = CMD;					\
+								\
+	assert_int_equal(get_cmdvec(cmd, &v, false), R);	\
+	if (R == 0) {						\
+		assert_ptr_not_equal(v, NULL);			\
+		assert_int_equal(fingerprint(v), FPR);		\
+		if (GOOD)					\
+			assert_ptr_not_equal(find_handler_for_cmdvec(v), NULL); \
+		else						\
+			assert_ptr_equal(find_handler_for_cmdvec(v), NULL); \
+		free_keys(v);					\
+	} else							\
+		assert_ptr_equal(v, NULL);			\
+}
+
+/*
+ * @NAME: test name
+ * @CMD: test command
+ * @FPR: fingerprint
+ * @PAR: value of parameter for keyword 1
+ */
+#define client_param(NAME, CMD, FPR, PAR)			\
+static void client_param_##NAME(void **state)			\
+{								\
+	vector v = NULL;					\
+	char cmd[] = CMD;					\
+								\
+	assert_int_equal(get_cmdvec(cmd, &v, false), 0);	\
+	assert_ptr_not_equal(v, NULL);				\
+	assert_int_equal(fingerprint(v), FPR);			\
+	assert_ptr_not_equal(find_handler_for_cmdvec(v), NULL);	\
+	assert_string_equal(((struct key *)VECTOR_SLOT(v, 1))->param, PAR); \
+	free_keys(v);						\
+}
+
+/*
+ * @NAME: test name
+ * @CMD: test command
+ * @FPR: fingerprint
+ * @PAR1: value of parameter for keyword 1
+ * @N: index of 2nd parameter keyword
+ * @PARN: value of parameter for keyword N
+ */
+#define client_2param(NAME, CMD, FPR, PAR1, N, PARN)		\
+static void client_2param_##NAME(void **state)			\
+{								\
+	vector v = NULL;					\
+	char cmd[] = CMD;					\
+								\
+	assert_int_equal(get_cmdvec(cmd, &v, false), 0);	\
+	assert_ptr_not_equal(v, NULL);				\
+	assert_int_equal(fingerprint(v), FPR);			\
+	assert_ptr_not_equal(find_handler_for_cmdvec(v), NULL);	\
+	assert_string_equal(((struct key *)VECTOR_SLOT(v, 1))->param, PAR1); \
+	assert_string_equal(((struct key *)VECTOR_SLOT(v, N))->param, PARN); \
+	free_keys(v);						\
+}
+
+static void client_test_null(void **state)
+{
+	vector v = NULL;
+
+	/* alloc_strvec() returns ENOMEM for NULL cmd */
+	assert_int_equal(get_cmdvec(NULL, &v, false), ENOMEM);
+	assert_ptr_equal(v, NULL);
+}
+
+/* alloc_strvec() returns ENOMEM for empty string */
+client_test(empty, "", ENOMEM, 0, false);
+client_test(bogus, "bogus", ESRCH, 0, false);
+client_test(list, "list", 0, VRB_LIST, false);
+client_test(show, "show", 0, VRB_LIST, false);
+client_test(s, "s", ESRCH, 0, false);
+/* partial match works if it's unique */
+client_test(sh, "sh", ESRCH, 0, false);
+client_test(sho, "sho", 0, VRB_LIST, false);
+client_test(add, "add", 0, VRB_ADD, false);
+client_test(resume, "resume", 0, VRB_RESUME, false);
+client_test(disablequeueing, "disablequeueing", 0, VRB_DISABLEQ, false);
+/* "disable" -> disablequeueing, "queueing" -> not found */
+client_test(disable_queueing, "disable queueing", ESRCH, 0, false);
+/* ENOENT because the not-found keyword is not last pos */
+client_test(queueing_disable, "queueing disable", ENOENT, 0, false);
+client_test(disable, "disable", 0, VRB_DISABLEQ, false);
+client_test(setprkey, "setprkey", 0, VRB_SETPRKEY, false);
+client_test(quit, "quit", 0, VRB_QUIT, true);
+client_test(exit, "exit", 0, VRB_QUIT, true);
+client_test(show_maps, "show maps", 0, VRB_LIST|Q1_MAPS, true);
+client_test(sh_maps, "sh maps", ENOENT, 0, 0);
+client_test(sho_maps, "sho maps", 0, VRB_LIST|Q1_MAPS, true);
+client_test(sho_multipaths, "sho multipaths", 0, VRB_LIST|Q1_MAPS, true);
+/* Needs a parameter */
+client_test(show_map, "show map", EINVAL, 0, 0);
+client_test(show_ma, "show ma", ESRCH, 0, 0);
+client_test(show_list_maps, "show list maps", 0,
+	    VRB_LIST|(VRB_LIST<<8)|(KEY_MAPS<<16), false);
+client_test(show_maps_list, "show maps list", 0,
+	    VRB_LIST|(VRB_LIST<<16)|(KEY_MAPS<<8), false);
+client_test(maps_show, "maps show ", 0, (VRB_LIST<<8)|KEY_MAPS, false);
+client_test(show_maps_list_json, "show maps list json", 0,
+	    VRB_LIST|(VRB_LIST<<16)|(KEY_MAPS<<8)|(KEY_JSON<<24), false);
+/* More than 4 keywords */
+client_test(show_maps_list_json_raw, "show maps list json raw", 0,
+	    INVALID_FINGERPRINT, false);
+client_test(show_list_show_list, "show list show list", 0,
+	    VRB_LIST|(VRB_LIST<<8)|(VRB_LIST<<16)|(VRB_LIST<<24), false);
+client_test(show_list_show_list_show, "show list show list  show", 0,
+	    INVALID_FINGERPRINT, false);
+client_test(q_q_q_q, "q q q q", 0,
+	    VRB_QUIT|(VRB_QUIT<<8)|(VRB_QUIT<<16)|(VRB_QUIT<<24), false);
+client_test(show_path_xy, "show path xy", 0, VRB_LIST|Q1_PATH, true);
+client_param(show_path_xy, "show path xy", VRB_LIST|Q1_PATH, "xy");
+client_param(show_path_xy_2, "show path \"xy\"", VRB_LIST|Q1_PATH, "xy");
+client_param(show_path_x_y, "show path \"x y\"", VRB_LIST|Q1_PATH, "x y");
+client_param(show_path_2inch, "show path \"2\"\"\"", VRB_LIST|Q1_PATH, "2\"");
+/* missing closing quote */
+client_param(show_path_2inch_1, "show path \"2\"\"", VRB_LIST|Q1_PATH, "2\"");
+client_test(show_map_xy, "show map xy", 0, VRB_LIST|Q1_MAP, false);
+client_test(show_map_xy_bogus, "show map xy bogus", ESRCH, 0, false);
+client_2param(show_map_xy_format_h, "show map xy form %h",
+	      VRB_LIST|Q1_MAP|Q2_FMT, "xy", 2, "%h");
+client_2param(show_map_xy_raw_format_h, "show map xy raw form %h",
+	      VRB_LIST|Q1_MAP|Q2_RAW|Q3_FMT, "xy", 3, "%h");
+client_test(show_map_xy_format_h_raw, "show map xy form %h raw", 0,
+	    VRB_LIST|(KEY_MAP<<8)|(KEY_FMT<<16)|(KEY_RAW<<24), false);
+client_param(list_path_sda, "list path sda", VRB_LIST|Q1_PATH, "sda");
+client_param(add_path_sda, "add path sda", VRB_ADD|Q1_PATH, "sda");
+client_test(list_list_path_sda, "list list path sda", 0,
+	    VRB_LIST|(VRB_LIST<<8)|(KEY_PATH<<16), false);
+
+static int client_tests(void)
+{
+	const struct CMUnitTest tests[] = {
+		cmocka_unit_test(client_test_null),
+		cmocka_unit_test(client_test_empty),
+		cmocka_unit_test(client_test_bogus),
+		cmocka_unit_test(client_test_list),
+		cmocka_unit_test(client_test_show),
+		cmocka_unit_test(client_test_s),
+		cmocka_unit_test(client_test_sh),
+		cmocka_unit_test(client_test_sho),
+		cmocka_unit_test(client_test_add),
+		cmocka_unit_test(client_test_resume),
+		cmocka_unit_test(client_test_disablequeueing),
+		cmocka_unit_test(client_test_disable_queueing),
+		cmocka_unit_test(client_test_queueing_disable),
+		cmocka_unit_test(client_test_disable),
+		cmocka_unit_test(client_test_setprkey),
+		cmocka_unit_test(client_test_quit),
+		cmocka_unit_test(client_test_exit),
+		cmocka_unit_test(client_test_show_maps),
+		cmocka_unit_test(client_test_sh_maps),
+		cmocka_unit_test(client_test_sho_maps),
+		cmocka_unit_test(client_test_sho_multipaths),
+		cmocka_unit_test(client_test_show_map),
+		cmocka_unit_test(client_test_show_ma),
+		cmocka_unit_test(client_test_maps_show),
+		cmocka_unit_test(client_test_show_list_maps),
+		cmocka_unit_test(client_test_show_maps_list),
+		cmocka_unit_test(client_test_show_maps_list_json),
+		cmocka_unit_test(client_test_show_maps_list_json_raw),
+		cmocka_unit_test(client_test_show_list_show_list),
+		cmocka_unit_test(client_test_show_list_show_list_show),
+		cmocka_unit_test(client_test_q_q_q_q),
+		cmocka_unit_test(client_test_show_map_xy),
+		cmocka_unit_test(client_test_show_map_xy_bogus),
+		cmocka_unit_test(client_test_show_path_xy),
+		cmocka_unit_test(client_param_show_path_xy),
+		cmocka_unit_test(client_param_show_path_xy_2),
+		cmocka_unit_test(client_param_show_path_x_y),
+		cmocka_unit_test(client_param_show_path_2inch),
+		cmocka_unit_test(client_param_show_path_2inch_1),
+		cmocka_unit_test(client_2param_show_map_xy_format_h),
+		cmocka_unit_test(client_2param_show_map_xy_raw_format_h),
+		cmocka_unit_test(client_test_show_map_xy_format_h_raw),
+		cmocka_unit_test(client_param_list_path_sda),
+		cmocka_unit_test(client_param_add_path_sda),
+		cmocka_unit_test(client_test_list_list_path_sda),
+	};
+
+	return cmocka_run_group_tests(tests, setup, teardown);
+}
+
+int main(void)
+{
+	int ret = 0;
+
+	init_test_verbosity(-1);
+	ret += client_tests();
+	return ret;
+}
--
2.37.2


From MAILER-DAEMON Tue Sep 27 19:37:20 2022
>From cb57b930fa690ab79b3904846634681685e3470f Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@suse.com>
Date: Thu, 1 Sep 2022 19:21:30 +0200
Subject: [PATCH v5 4/5] multipath-tools: use /run instead of /dev/shm

/dev/shm may have unsafe permissions. Use /run instead.
Use systemd's tmpfiles.d mechanism to create /run/multipath
early during boot.

For backward compatibilty, make the runtime directory configurable
via the "runtimedir" make variable.

Signed-off-by: Martin Wilck <mwilck@suse.com>
Reviewed-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 .gitignore                                        |  2 ++
 Makefile.inc                                      |  3 +++
 libmultipath/defaults.h                           |  2 +-
 multipath/Makefile                                | 11 ++++++++---
 multipath/{multipath.rules => multipath.rules.in} |  4 ++--
 multipath/tmpfiles.conf.in                        |  1 +
 6 files changed, 17 insertions(+), 6 deletions(-)
 rename multipath/{multipath.rules => multipath.rules.in} (95%)
 create mode 100644 multipath/tmpfiles.conf.in

diff --git a/.gitignore b/.gitignore
index 821c3e6..83f8a55 100644
--- a/.gitignore
+++ b/.gitignore
@@ -12,6 +12,8 @@ cscope.files
 cscope.out
 kpartx/kpartx
 multipath/multipath
+multipath/multipath.rules
+multipath/tmpfiles.conf
 multipathd/multipathd
 multipathd/multipathc
 mpathpersist/mpathpersist
diff --git a/Makefile.inc b/Makefile.inc
index 50472c0..5602506 100644
--- a/Makefile.inc
+++ b/Makefile.inc
@@ -83,6 +83,7 @@ exec_prefix	= $(prefix)
 usr_prefix	= $(prefix)
 bindir		= $(exec_prefix)/sbin
 libudevdir	= $(prefix)/$(SYSTEMDPATH)/udev
+tmpfilesdir	= $(prefix)/$(SYSTEMDPATH)/tmpfiles.d
 udevrulesdir	= $(libudevdir)/rules.d
 modulesloaddir  = $(prefix)/$(SYSTEMDPATH)/modules-load.d
 multipathdir	= $(TOPDIR)/libmultipath
@@ -105,6 +106,7 @@ includedir	= $(prefix)/usr/include
 pkgconfdir	= $(usrlibdir)/pkgconfig
 plugindir       := $(prefix)/$(LIB)/multipath
 configdir       := $(prefix)/etc/multipath/conf.d
+runtimedir      := /$(RUN)

 GZIP_PROG	= gzip -9 -c
 RM		= rm -f
@@ -149,6 +151,7 @@ WARNFLAGS	:= -Werror -Wall -Wextra -Wformat=2 $(WFORMATOVERFLOW) -Werror=implici
 		  $(WNOCLOBBERED) -Werror=cast-qual $(ERROR_DISCARDED_QUALIFIERS)
 CPPFLAGS	:= $(FORTIFY_OPT) \
 		   -DBIN_DIR=\"$(bindir)\" -DMULTIPATH_DIR=\"$(plugindir)\" -DRUN_DIR=\"${RUN}\" \
+		   -DRUNTIME_DIR=\"$(runtimedir)\" \
 		   -DCONFIG_DIR=\"$(configdir)\" -DEXTRAVERSION=\"$(EXTRAVERSION)\" -MMD -MP
 CFLAGS		:= --std=gnu99 $(CFLAGS) $(OPTFLAGS) $(WARNFLAGS) -pipe
 BIN_CFLAGS	= -fPIE -DPIE
diff --git a/libmultipath/defaults.h b/libmultipath/defaults.h
index 7979f20..3d552b3 100644
--- a/libmultipath/defaults.h
+++ b/libmultipath/defaults.h
@@ -68,7 +68,7 @@
 #define DEFAULT_BINDINGS_FILE	"/etc/multipath/bindings"
 #define DEFAULT_WWIDS_FILE	"/etc/multipath/wwids"
 #define DEFAULT_PRKEYS_FILE    "/etc/multipath/prkeys"
-#define MULTIPATH_SHM_BASE	"/dev/shm/multipath/"
+#define MULTIPATH_SHM_BASE	RUNTIME_DIR "/multipath/"


 static inline char *set_default(char *str)
diff --git a/multipath/Makefile b/multipath/Makefile
index 46b7553..116348e 100644
--- a/multipath/Makefile
+++ b/multipath/Makefile
@@ -13,7 +13,7 @@ EXEC = multipath

 OBJS = main.o

-all: $(EXEC)
+all: $(EXEC) multipath.rules tmpfiles.conf

 $(EXEC): $(OBJS) $(multipathdir)/libmultipath.so $(mpathcmddir)/libmpathcmd.so
 	$(CC) $(CFLAGS) $(OBJS) -o $(EXEC) $(LDFLAGS) $(LIBDEPS)
@@ -23,9 +23,11 @@ install:
 	$(INSTALL_PROGRAM) -m 755 $(EXEC) $(DESTDIR)$(bindir)/
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(udevrulesdir)
 	$(INSTALL_PROGRAM) -m 644 11-dm-mpath.rules $(DESTDIR)$(udevrulesdir)
-	$(INSTALL_PROGRAM) -m 644 $(EXEC).rules $(DESTDIR)$(udevrulesdir)/56-multipath.rules
+	$(INSTALL_PROGRAM) -m 644 multipath.rules $(DESTDIR)$(udevrulesdir)/56-multipath.rules
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(modulesloaddir)
 	$(INSTALL_PROGRAM) -m 644 modules-load.conf $(DESTDIR)$(modulesloaddir)/multipath.conf
+	$(INSTALL_PROGRAM) -d $(DESTDIR)$(tmpfilesdir)
+	$(INSTALL_PROGRAM) -m 644 tmpfiles.conf $(DESTDIR)$(tmpfilesdir)/multipath.conf
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(man8dir)
 	$(INSTALL_PROGRAM) -m 644 $(EXEC).8 $(DESTDIR)$(man8dir)
 	$(INSTALL_PROGRAM) -d $(DESTDIR)$(man5dir)
@@ -46,9 +48,12 @@ uninstall:
 	$(RM) $(DESTDIR)$(man5dir)/$(EXEC).conf.5

 clean: dep_clean
-	$(RM) core *.o $(EXEC)
+	$(RM) core *.o $(EXEC) multipath.rules tmpfiles.conf

 include $(wildcard $(OBJS:.o=.d))

 dep_clean:
 	$(RM) $(OBJS:.o=.d)
+
+%:	%.in
+	sed 's,@RUNTIME_DIR@,$(runtimedir),' $< >$@
diff --git a/multipath/multipath.rules b/multipath/multipath.rules.in
similarity index 95%
rename from multipath/multipath.rules
rename to multipath/multipath.rules.in
index f993d99..8d3cf33 100644
--- a/multipath/multipath.rules
+++ b/multipath/multipath.rules.in
@@ -1,8 +1,8 @@
 # Set DM_MULTIPATH_DEVICE_PATH if the device should be handled by multipath
 SUBSYSTEM!="block", GOTO="end_mpath"
 KERNEL!="sd*|dasd*|nvme*", GOTO="end_mpath"
-ACTION=="remove", TEST=="/dev/shm/multipath/find_multipaths/$major:$minor", \
-	RUN+="/usr/bin/rm -f /dev/shm/multipath/find_multipaths/$major:$minor"
+ACTION=="remove", TEST=="@RUNTIME_DIR@/multipath/find_multipaths/$major:$minor", \
+	RUN+="/usr/bin/rm -f @RUNTIME_DIR@/multipath/find_multipaths/$major:$minor"
 ACTION!="add|change", GOTO="end_mpath"

 IMPORT{cmdline}="nompath"
diff --git a/multipath/tmpfiles.conf.in b/multipath/tmpfiles.conf.in
new file mode 100644
index 0000000..21be438
--- /dev/null
+++ b/multipath/tmpfiles.conf.in
@@ -0,0 +1 @@
+d @RUNTIME_DIR@/multipath 0700 root root -
--
2.37.2


From MAILER-DAEMON Tue Sep 27 19:37:20 2022
>From 994811a29332161ec150f1d9822ff460cfc0f316 Mon Sep 17 00:00:00 2001
From: Martin Wilck <mwilck@suse.com>
Date: Wed, 7 Sep 2022 11:32:29 +0200
Subject: [PATCH v5 5/5] multipathd: uxlsnr: fix memory leak handling invalid
 commands

If a client sends invalid commands with at least one correct keyword,
(e.g "show bogus"), get_cmdvec() returns 0 and c->cmdvec is allocated but
never freed. Fix it by freeing the cmdvec when setting the state to
CLT_SEND.

Signed-off-by: Martin Wilck <mwilck@suse.com>
Suggested-by: Qualys Security Advisory <qsa@qualys.com>
Reviewed-by: Benjamin Marzinski <bmarzins@redhat.com>
---
 multipathd/uxlsnr.c | 9 +++++----
 1 file changed, 5 insertions(+), 4 deletions(-)

diff --git a/multipathd/uxlsnr.c b/multipathd/uxlsnr.c
index 91b9079..02e89fb 100644
--- a/multipathd/uxlsnr.c
+++ b/multipathd/uxlsnr.c
@@ -412,6 +412,11 @@ static void set_client_state(struct client *c, int state)
 		c->expires = ts_zero;
 		/* reuse these fields for next data transfer */
 		c->len = c->cmd_len = 0;
+		/* cmdvec isn't needed any more */
+		if (c->cmdvec) {
+			free_keys(c->cmdvec);
+			c->cmdvec = NULL;
+		}
 		break;
 	default:
 		break;
@@ -506,8 +511,6 @@ static int client_state_machine(struct client *c, struct vectors *vecs,
 			check_for_locked_work(c);
 			pthread_cleanup_pop(1);
 			condlog(4, "%s: cli[%d] grabbed lock", __func__, c->fd);
-			free_keys(c->cmdvec);
-			c->cmdvec = NULL;
 			set_client_state(c, CLT_SEND);
 			/* Wait for POLLOUT */
 			return STM_BREAK;
@@ -518,8 +521,6 @@ static int client_state_machine(struct client *c, struct vectors *vecs,

 	case CLT_WORK:
 		c->error = execute_handler(c, vecs);
-		free_keys(c->cmdvec);
-		c->cmdvec = NULL;
 		set_client_state(c, CLT_SEND);
 		/* Wait for POLLOUT */
 		return STM_BREAK;
--
2.37.2

