etcdserver: protect lease timetilive with auth
Signed-off-by: Hitoshi Mitake <h.mitake@gmail.com>
Co-authored-by: Benjamin Wang <wachao@vmware.com>

tests: e2e and integration test for timetolive

---
 server/etcdserver/v3_server.go    | 51 ++++++++++++++++-
 tests/e2e/ctl_v3_auth_test.go     | 49 +++++++++++++++++
 tests/e2e/ctl_v3_lease_test.go    |  8 +++
 tests/integration/v3_auth_test.go | 91 +++++++++++++++++++++++++++++--
 4 files changed, 193 insertions(+), 6 deletions(-)

diff --git a/server/etcdserver/v3_server.go b/server/etcdserver/v3_server.go
index c4e93970c..b4f74aee2 100644
--- a/server/etcdserver/v3_server.go
+++ b/server/etcdserver/v3_server.go
@@ -314,7 +314,32 @@ func (s *EtcdServer) LeaseRenew(ctx context.Context, id lease.LeaseID) (int64, e
 	return -1, ErrCanceled
 }
 
-func (s *EtcdServer) LeaseTimeToLive(ctx context.Context, r *pb.LeaseTimeToLiveRequest) (*pb.LeaseTimeToLiveResponse, error) {
+func (s *EtcdServer) checkLeaseTimeToLive(ctx context.Context, leaseID lease.LeaseID) (error, uint64) {
+       rev := s.AuthStore().Revision()
+       if !s.AuthStore().IsAuthEnabled() {
+               return nil, rev
+       }
+       authInfo, err := s.AuthInfoFromCtx(ctx)
+       if err != nil {
+               return err, rev
+       }
+       if authInfo == nil {
+               return auth.ErrUserEmpty, rev
+       }
+
+       l := s.lessor.Lookup(leaseID)
+       if l != nil {
+               for _, key := range l.Keys() {
+                       if err := s.AuthStore().IsRangePermitted(authInfo, []byte(key), []byte{}); err != nil {
+                               return err, 0
+                       }
+               }
+       }
+
+       return nil, rev
+}
+
+func (s *EtcdServer) leaseTimeToLive(ctx context.Context, r *pb.LeaseTimeToLiveRequest) (*pb.LeaseTimeToLiveResponse, error) {
 	if s.Leader() == s.ID() {
 		// primary; timetolive directly from leader
 		le := s.lessor.Lookup(lease.LeaseID(r.ID))
@@ -361,6 +386,30 @@ func (s *EtcdServer) LeaseTimeToLive(ctx context.Context, r *pb.LeaseTimeToLiveR
 	return nil, ErrCanceled
 }
 
+func (s *EtcdServer) LeaseTimeToLive(ctx context.Context, r *pb.LeaseTimeToLiveRequest) (*pb.LeaseTimeToLiveResponse, error) {
+       var rev uint64
+       var err error
+       if r.Keys {
+               // check RBAC permission only if Keys is true
+               err, rev = s.checkLeaseTimeToLive(ctx, lease.LeaseID(r.ID))
+               if err != nil {
+                       return nil, err
+               }
+       }
+
+       resp, err := s.leaseTimeToLive(ctx, r)
+       if err != nil {
+               return nil, err
+       }
+
+       if r.Keys {
+               if s.AuthStore().IsAuthEnabled() && rev != s.AuthStore().Revision() {
+                       return nil, auth.ErrAuthOldRevision
+               }
+       }
+       return resp, nil
+}
+
 func (s *EtcdServer) LeaseLeases(ctx context.Context, r *pb.LeaseLeasesRequest) (*pb.LeaseLeasesResponse, error) {
 	ls := s.lessor.Leases()
 	lss := make([]*pb.LeaseStatus, len(ls))
diff --git a/tests/e2e/ctl_v3_auth_test.go b/tests/e2e/ctl_v3_auth_test.go
index 11db1b389..7e1c3c495 100644
--- a/tests/e2e/ctl_v3_auth_test.go
+++ b/tests/e2e/ctl_v3_auth_test.go
@@ -70,6 +70,7 @@ func TestCtlV3AuthSnapshot(t *testing.T)            { testCtl(t, authTestSnapsho
 func TestCtlV3AuthSnapshotJWT(t *testing.T)         { testCtl(t, authTestSnapshot, withCfg(*newConfigJWT())) }
 func TestCtlV3AuthJWTExpire(t *testing.T)           { testCtl(t, authTestJWTExpire, withCfg(*newConfigJWT())) }
 func TestCtlV3AuthRevisionConsistency(t *testing.T) { testCtl(t, authTestRevisionConsistency) }
+func TestCtlV3AuthLeaseTimeToLive(t *testing.T)     { testCtl(t, authTestLeaseTimeToLive) }
 
 func authEnableTest(cx ctlCtx) {
 	if err := authEnable(cx); err != nil {
@@ -91,6 +92,54 @@ func authEnable(cx ctlCtx) error {
 	return nil
 }
 
+func authTestLeaseTimeToLive(cx ctlCtx) {
+       if err := authEnable(cx); err != nil {
+               cx.t.Fatal(err)
+       }
+       cx.user, cx.pass = "root", "root"
+
+       authSetupTestUser(cx)
+
+       cx.user = "test-user"
+       cx.pass = "pass"
+
+       leaseID, err := ctlV3LeaseGrant(cx, 10)
+       if err != nil {
+               cx.t.Fatal(err)
+       }
+
+       err = ctlV3Put(cx, "foo", "val", leaseID)
+       if err != nil {
+               cx.t.Fatal(err)
+       }
+
+       err = ctlV3LeaseTimeToLive(cx, leaseID, true)
+       if err != nil {
+               cx.t.Fatal(err)
+       }
+
+       cx.user = "root"
+       cx.pass = "root"
+       err = ctlV3Put(cx, "bar", "val", leaseID)
+       if err != nil {
+              cx.t.Fatal(err)
+       }
+
+       cx.user = "test-user"
+       cx.pass = "pass"
+       // the lease is attached to bar, which test-user cannot access
+       err = ctlV3LeaseTimeToLive(cx, leaseID, true)
+       if err == nil {
+               cx.t.Fatal("test-user must not be able to access to the lease, because it's attached to the key bar")
+       }
+
+       // without --keys, access should be allowed
+       err = ctlV3LeaseTimeToLive(cx, leaseID, false)
+       if err != nil {
+               cx.t.Fatal(err)
+       }
+}
+
 func ctlV3AuthEnable(cx ctlCtx) error {
 	cmdArgs := append(cx.PrefixArgs(), "auth", "enable")
 	return spawnWithExpectWithEnv(cmdArgs, cx.envMap, "Authentication Enabled")
diff --git a/tests/e2e/ctl_v3_lease_test.go b/tests/e2e/ctl_v3_lease_test.go
index 0dc445202..87aeb1c66 100644
--- a/tests/e2e/ctl_v3_lease_test.go
+++ b/tests/e2e/ctl_v3_lease_test.go
@@ -300,3 +300,11 @@ func ctlV3LeaseRevoke(cx ctlCtx, leaseID string) error {
 	cmdArgs := append(cx.PrefixArgs(), "lease", "revoke", leaseID)
 	return spawnWithExpectWithEnv(cmdArgs, cx.envMap, fmt.Sprintf("lease %s revoked", leaseID))
 }
+
+func ctlV3LeaseTimeToLive(cx ctlCtx, leaseID string, withKeys bool) error {
+       cmdArgs := append(cx.PrefixArgs(), "lease", "timetolive", leaseID)
+       if withKeys {
+               cmdArgs = append(cmdArgs, "--keys")
+       }
+       return e2e.SpawnWithExpectWithEnv(cmdArgs, cx.envMap, fmt.Sprintf("lease %s granted with", leaseID))
+}
diff --git a/tests/integration/v3_auth_test.go b/tests/integration/v3_auth_test.go
index 286f2dbe6..a52f7c4a0 100644
--- a/tests/integration/v3_auth_test.go
+++ b/tests/integration/v3_auth_test.go
@@ -150,12 +150,10 @@ func testV3AuthWithLeaseRevokeWithRoot(t *testing.T, ccfg ClusterConfig) {
 	// wait for lease expire
 	time.Sleep(3 * time.Second)
 
-	tresp, terr := api.Lease.LeaseTimeToLive(
+	tresp, terr := rootc.TimeToLive(
 		context.TODO(),
-		&pb.LeaseTimeToLiveRequest{
-			ID:   int64(leaseID),
-			Keys: true,
-		},
+		leaseID,
+		clientv3.WithAttachedKeys(),
 	)
 	if terr != nil {
 		t.Error(terr)
@@ -394,3 +392,86 @@ func TestV3AuthOldRevConcurrent(t *testing.T) {
 	}
 	wg.Wait()
 }
+
+func TestV3AuthWithLeaseTimeToLive(t *testing.T) {
+       integration.BeforeTest(t)
+       clus := integration.NewCluster(t, &integration.ClusterConfig{Size: 1})
+       defer clus.Terminate(t)
+
+       users := []user{
+               {
+                       name:     "user1",
+                       password: "user1-123",
+                       role:     "role1",
+                       key:      "k1",
+                       end:      "k3",
+               },
+               {
+                       name:     "user2",
+                       password: "user2-123",
+                       role:     "role2",
+                       key:      "k2",
+                       end:      "k4",
+               },
+       }
+       authSetupUsers(t, integration.ToGRPC(clus.Client(0)).Auth, users)
+
+       authSetupRoot(t, integration.ToGRPC(clus.Client(0)).Auth)
+
+       user1c, cerr := integration.NewClient(t, clientv3.Config{Endpoints: clus.Client(0).Endpoints(), Username: "user1", Password: "user1-123"})
+       if cerr != nil {
+               t.Fatal(cerr)
+       }
+       defer user1c.Close()
+
+       user2c, cerr := integration.NewClient(t, clientv3.Config{Endpoints: clus.Client(0).Endpoints(), Username: "user2", Password: "user2-123"})
+       if cerr != nil {
+               t.Fatal(cerr)
+       }
+       defer user2c.Close()
+
+       leaseResp, err := user1c.Grant(context.TODO(), 90)
+       if err != nil {
+               t.Fatal(err)
+       }
+       leaseID := leaseResp.ID
+       _, err = user1c.Put(context.TODO(), "k1", "val", clientv3.WithLease(leaseID))
+       if err != nil {
+               t.Fatal(err)
+       }
+       // k2 can be accessed from both user1 and user2
+       _, err = user1c.Put(context.TODO(), "k2", "val", clientv3.WithLease(leaseID))
+       if err != nil {
+               t.Fatal(err)
+       }
+
+       _, err = user1c.TimeToLive(context.TODO(), leaseID)
+       if err != nil {
+               t.Fatal(err)
+       }
+
+       _, err = user2c.TimeToLive(context.TODO(), leaseID)
+       if err != nil {
+               t.Fatal(err)
+       }
+
+       _, err = user2c.TimeToLive(context.TODO(), leaseID, clientv3.WithAttachedKeys())
+       if err == nil {
+               t.Fatal("timetolive from user2 should be failed with permission denied")
+       }
+
+       rootc, cerr := integration.NewClient(t, clientv3.Config{Endpoints: clus.Client(0).Endpoints(), Username: "root", Password: "123"})
+       if cerr != nil {
+               t.Fatal(cerr)
+       }
+       defer rootc.Close()
+
+       if _, err := rootc.RoleRevokePermission(context.TODO(), "role1", "k1", "k3"); err != nil {
+               t.Fatal(err)
+       }
+
+       _, err = user1c.TimeToLive(context.TODO(), leaseID, clientv3.WithAttachedKeys())
+       if err == nil {
+               t.Fatal("timetolive from user2 should be failed with permission denied")
+       }
+}
-- 
2.35.6

