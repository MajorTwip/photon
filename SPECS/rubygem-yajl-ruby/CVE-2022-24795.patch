From 75d2b6d99bd5f71322f1b78c94f5c292de174e91 Mon Sep 17 00:00:00 2001
From: John Hawthorn <john@hawthorn.email>
Date: Tue, 1 Mar 2022 15:26:48 -0800
Subject: [PATCH] Track an error state on yajl_buf

From 36410d536b676e836637bb20574a56ebc920eb83 Mon Sep 17 00:00:00 2001
From: John Hawthorn <john@hawthorn.email>
Date: Wed, 2 Mar 2022 14:17:59 -0800
Subject: [PATCH] Check need < buf->used

We're guaranteed a power of 2 so that this becomes 0, but we might as
well use a check for overflow that works in more cases.

Unsigned integer overflow is defined behaviour, so this should be safe.

--- a/ext/yajl/yajl_buf.c	2022-05-31 07:17:14.093527001 +0530
+++ b/ext/yajl/yajl_buf.c	2022-05-31 07:38:39.380098032 +0530
@@ -38,35 +38,77 @@
 
 #define YAJL_BUF_INIT_SIZE 2048
 
+typedef enum {
+     yajl_buf_ok = 0,
+     yajl_buf_alloc_failed,
+     yajl_buf_overflow
+} yajl_buf_state;
+
 struct yajl_buf_t {
+    yajl_buf_state state;
     unsigned int len;
     unsigned int used;
     unsigned char * data;
     yajl_alloc_funcs * alloc;
 };
 
+#include <stdio.h>
+
 static
-void yajl_buf_ensure_available(yajl_buf buf, unsigned int want)
+yajl_buf_state yajl_buf_set_error(yajl_buf buf, yajl_buf_state err)
+{
+    buf->state = err;
+
+    // free and clear all data from the buffer
+    YA_FREE(buf->alloc, buf->data);
+    buf->len = 0;
+    buf->data = 0;
+    buf->used = 0;
+
+    return err;
+}
+
+static
+yajl_buf_state yajl_buf_ensure_available(yajl_buf buf, unsigned int want)
 {
     unsigned int need;
     
     assert(buf != NULL);
 
+    if (buf->state != yajl_buf_ok) {
+        return buf->state;
+    }
+
     /* first call */
     if (buf->data == NULL) {
         buf->len = YAJL_BUF_INIT_SIZE;
         buf->data = (unsigned char *) YA_MALLOC(buf->alloc, buf->len);
+		if (buf->data == NULL)  {
+            return yajl_buf_set_error(buf, yajl_buf_overflow);
+        }
         buf->data[0] = 0;
     }
+    if (want == 0) {
+        return yajl_buf_ok;
+    }
 
     need = buf->len;
 
     while (want >= (need - buf->used)) need <<= 1;
 
+    // Check for overflow
+    if (need < buf->used) {
+        return yajl_buf_set_error(buf, yajl_buf_overflow);
+    }
+
     if (need != buf->len) {
         buf->data = (unsigned char *) YA_REALLOC(buf->alloc, buf->data, need);
+		if (buf->data == NULL)  {
+            return yajl_buf_set_error(buf, yajl_buf_overflow);
+        }
         buf->len = need;
     }
+    return yajl_buf_ok;
 }
 
 yajl_buf yajl_buf_alloc(yajl_alloc_funcs * alloc)
