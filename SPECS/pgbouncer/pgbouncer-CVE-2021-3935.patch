From 6311030a2f3d389a2270967fed4c300bd4a7f604 Mon Sep 17 00:00:00 2001
From: Peter Eisentraut <peter@eisentraut.org>
Date: Thu, 4 Nov 2021 07:55:57 +0100
Subject: [PATCH] Reject extraneous data after SSL or GSS encryption handshakes

PgBouncer, talking to a client (so PgBouncer is the server), collects
up to a bufferload of data whenever it reads data from the client
socket.  When SSL or GSS encryption is requested during startup, any
additional data received with the initial request message remained in
the buffer, and would be treated as already-decrypted data once the
encryption handshake completed.  Thus, a man-in-the-middle with the
ability to inject data into the TCP connection could stuff some
cleartext data into the start of a supposedly encryption-protected
database session.

This could be abused to send faked SQL commands to PgBouncer, although
it would only work if PgBouncer did not demand any authentication
data.  (However, an instance relying on SSL certificate authentication
might well not do so.)

To fix, throw a protocol-violation error if the internal buffer is not
empty after the encryption handshake.

(PgBouncer does not support GSS encryption, but we put the check in
place anyway for completeness.)

The analogous issue with PgBouncer talking to a server (so PgBouncer
is the client) did not exist, since there was already a check whether
the buffer was empty after reading an SSL response.  But just for
clarity, split out that check and give it its own error message.

Based on security report for PostgreSQL, reported by Jacob Champion,
code by Tom Lane; PgBouncer code by Peter Eisentraut, reviewed by
Andrew Dunstan
[Ankit: Backported the patch for v1.9.x]
Signed-off-by: Ankit Jain <ankitja@vmware.com>
---
 src/client.c | 18 ++++++++++++++++++
 src/server.c | 12 +++++++++++-
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/src/client.c b/src/client.c
index 2a46e0d..6e3c19a 100644
--- a/src/client.c
+++ b/src/client.c
@@ -739,6 +739,24 @@ bool client_proto(SBuf *sbuf, SBufEvent evtype, struct MBuf *data)
 		}
 		slog_noise(client, "pkt='%c' len=%d", pkt_desc(&pkt), pkt.len);
 
+		/*
+		 * If we are reading an SSL request or GSSAPI
+		 * encryption request, we should have no data already
+		 * buffered at this point.  If we do, it was received
+		 * before we performed the SSL or GSSAPI handshake, so
+		 * it wasn't encrypted and indeed may have been
+		 * injected by a man-in-the-middle.  We report this
+		 * case to the client.
+		 */
+		if (pkt.type == PKT_SSLREQ && mbuf_avail_for_read(data) > 0) {
+			disconnect_client(client, true, "received unencrypted data after SSL request");
+			return false;
+		}
+		if (pkt.type == PKT_GSSENCREQ && mbuf_avail_for_read(data) > 0) {
+			disconnect_client(client, true, "received unencrypted data after GSSAPI encryption request");
+			return false;
+		}
+
 		client->request_time = get_cached_time();
 		switch (client->state) {
 		case CL_LOGIN:
diff --git a/src/server.c b/src/server.c
index 5197566..e7d5466 100644
--- a/src/server.c
+++ b/src/server.c
@@ -431,10 +431,20 @@ static bool handle_sslchar(PgSocket *server, struct MBuf *data)
 	server->wait_sslchar = false;
 
 	ok = mbuf_get_byte(data, &schar);
-	if (!ok || (schar != 'S' && schar != 'N') || mbuf_avail_for_read(data) != 0) {
+	if (!ok || (schar != 'S' && schar != 'N')) {
 		disconnect_server(server, false, "bad sslreq answer");
 		return false;
 	}
+	/*
+	 * At this point we should have no data already buffered.  If
+	 * we do, it was received before we performed the SSL
+	 * handshake, so it wasn't encrypted and indeed may have been
+	 * injected by a man-in-the-middle.
+	 */
+	if (mbuf_avail_for_read(data) != 0) {
+		disconnect_server(server, false, "received unencrypted data after SSL response");
+		return false;
+	}
 
 	if (schar == 'S') {
 		slog_noise(server, "launching tls");
-- 
2.23.1

