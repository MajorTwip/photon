From a887c6c18d54ec736b9f3c9bb3391e7f830a3295 Mon Sep 17 00:00:00 2001
From: Jonathan Shao <sjonathan@vmware.com>
Date: Tue, 14 Jun 2022 15:28:25 -0700
Subject: [PATCH 14/16] iptunnel mark xfrm multi parts

This patch modifies several places for HCX specific purpose.
---
 include/net/dst_cache.h | 28 +++++++++++++++++++++++
 net/core/dst_cache.c    | 50 +++++++++++++++++++++++++++++++++++++----
 net/ipv4/ip_tunnel.c    | 39 +++++++++++++++++++++++++++-----
 3 files changed, 108 insertions(+), 9 deletions(-)

diff --git a/include/net/dst_cache.h b/include/net/dst_cache.h
index 67634675e..e5aa0737f 100644
--- a/include/net/dst_cache.h
+++ b/include/net/dst_cache.h
@@ -32,6 +32,19 @@ struct dst_entry *dst_cache_get(struct dst_cache *dst_cache);
  */
 struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr);
 
+/**
+ *	dst_cache_get_ip4_use_mark - perform cache lookup and fetch ipv4 source
+ *	                             using custom mark
+ *	@dst_cache: the cache
+ *	@saddr: return value for the retrieved source address
+ *	@mark : the custom mark
+ *	@use_mark: enables using the mark (allows using zero for mark value)
+ *
+ *	local BH must be disabled.
+ */
+struct rtable *dst_cache_get_ip4_use_mark(struct dst_cache *dst_cache,
+        __be32 *saddr, u32 mark);
+
 /**
  *	dst_cache_set_ip4 - store the ipv4 dst into the cache
  *	@dst_cache: the cache
@@ -43,6 +56,21 @@ struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr);
 void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
 		       __be32 saddr);
 
+/**
+ *	dst_cache_set_ip4_use_mark - store the ipv4 dst into the cache using
+ *	                             custom mark
+ *	@dst_cache: the cache
+ *	@dst: the entry to be cached
+ *	@saddr: the source address to be stored inside the cache
+ *	@mark : the custom mark
+ *	@use_mark: enables using the mark (allows using zero for mark value)
+ *
+ *	local BH must be disabled.
+ */
+void dst_cache_set_ip4_use_mark(struct dst_cache *dst_cache,
+		        struct dst_entry *dst, __be32 saddr, u32 mark);
+
+
 #if IS_ENABLED(CONFIG_IPV6)
 
 /**
diff --git a/net/core/dst_cache.c b/net/core/dst_cache.c
index 64cef9774..ba7d1b306 100644
--- a/net/core/dst_cache.c
+++ b/net/core/dst_cache.c
@@ -26,6 +26,7 @@ struct dst_cache_pcpu {
 		struct in_addr in_saddr;
 		struct in6_addr in6_saddr;
 	};
+	u32 mark;
 };
 
 static void dst_cache_per_cpu_dst_set(struct dst_cache_pcpu *dst_cache,
@@ -73,7 +74,8 @@ struct dst_entry *dst_cache_get(struct dst_cache *dst_cache)
 }
 EXPORT_SYMBOL_GPL(dst_cache_get);
 
-struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr)
+static struct rtable *__dst_cache_get_ip4(struct dst_cache *dst_cache,
+        __be32 *saddr, u32 mark, bool use_mark)
 {
 	struct dst_cache_pcpu *idst;
 	struct dst_entry *dst;
@@ -86,13 +88,36 @@ struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr)
 	if (!dst)
 		return NULL;
 
-	*saddr = idst->in_saddr.s_addr;
+	if (use_mark) {
+		if (idst->mark == mark) {
+			*saddr = idst->in_saddr.s_addr;
+		} else {
+			dst_cache_set_ip4_use_mark(dst_cache, NULL, 0, 0);
+			dst_release(dst);
+			dst = NULL;
+			return NULL;
+		}
+	} else {
+		*saddr = idst->in_saddr.s_addr;
+	}
 	return container_of(dst, struct rtable, dst);
 }
+
+struct rtable *dst_cache_get_ip4(struct dst_cache *dst_cache, __be32 *saddr)
+{
+	return __dst_cache_get_ip4(dst_cache, saddr, 0, false);
+}
 EXPORT_SYMBOL_GPL(dst_cache_get_ip4);
 
-void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
-		       __be32 saddr)
+struct rtable *dst_cache_get_ip4_use_mark(struct dst_cache *dst_cache,
+        __be32 *saddr, u32 mark)
+{
+	return __dst_cache_get_ip4(dst_cache, saddr, mark, true);
+}
+EXPORT_SYMBOL_GPL(dst_cache_get_ip4_use_mark);
+
+static void __dst_cache_set_ip4(struct dst_cache *dst_cache,
+        struct dst_entry *dst, __be32 saddr, u32 mark, u32 use_mark)
 {
 	struct dst_cache_pcpu *idst;
 
@@ -102,9 +127,26 @@ void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
 	idst = this_cpu_ptr(dst_cache->cache);
 	dst_cache_per_cpu_dst_set(idst, dst, 0);
 	idst->in_saddr.s_addr = saddr;
+	if (use_mark) {
+		idst->mark = mark;
+	}
+}
+
+void dst_cache_set_ip4(struct dst_cache *dst_cache, struct dst_entry *dst,
+               __be32 saddr)
+{
+	__dst_cache_set_ip4(dst_cache, dst, saddr, 0, true);
 }
 EXPORT_SYMBOL_GPL(dst_cache_set_ip4);
 
+void dst_cache_set_ip4_use_mark(struct dst_cache *dst_cache,
+        struct dst_entry *dst, __be32 saddr, u32 mark)
+{
+
+	__dst_cache_set_ip4(dst_cache, dst, saddr, mark, true);
+}
+EXPORT_SYMBOL_GPL(dst_cache_set_ip4_use_mark);
+
 #if IS_ENABLED(CONFIG_IPV6)
 void dst_cache_set_ip6(struct dst_cache *dst_cache, struct dst_entry *dst,
 		       const struct in6_addr *saddr)
diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c
index 4a6359a11..24a2123fe 100644
--- a/net/ipv4/ip_tunnel.c
+++ b/net/ipv4/ip_tunnel.c
@@ -70,9 +70,11 @@
 struct ctl_table_header *ipip_sysctl_header = NULL;
 int ipip_tunnel_skip_encap_decap __read_mostly = 0;
 int fou_key_multi_port __read_mostly = 0;
+int ipip_dst_cache_use_mark __read_mostly = 0;
 EXPORT_SYMBOL_GPL(ipip_tunnel_skip_encap_decap);
 EXPORT_SYMBOL_GPL(ipip_sysctl_header);
 EXPORT_SYMBOL_GPL(fou_key_multi_port);
+EXPORT_SYMBOL_GPL(ipip_dst_cache_use_mark);
 
 struct ctl_table ipip_sysctl_table[] = {
 	{
@@ -89,6 +91,14 @@ struct ctl_table ipip_sysctl_table[] = {
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
+	{
+		.procname       = "ipip_dst_cache_use_mark",
+		.data           = &ipip_dst_cache_use_mark,
+		.maxlen         = sizeof(int),
+		.mode           = 0644,
+		.proc_handler   = proc_dointvec,
+	},
+
 	{}
 };
 EXPORT_SYMBOL_GPL(ipip_sysctl_table);
@@ -107,6 +117,7 @@ EXPORT_SYMBOL_GPL(ipip_sysctl_init);
 #else
 #define ipip_tunnel_skip_encap_decap 0
 #define fou_key_multi_port 0
+#define ipip_dst_cache_use_mark 0
 #endif
 
 static unsigned int ip_tunnel_hash(__be32 key, __be32 remote)
@@ -770,15 +781,27 @@ void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 		}
 	}
 
-	ip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,
+	if(ipip_dst_cache_use_mark) {
+		ip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,
+			    tunnel->parms.o_key, RT_TOS(tos), tunnel->parms.link,
+			    skb->mark);
+	} else {
+		ip_tunnel_init_flow(&fl4, protocol, dst, tnl_params->saddr,
 			    tunnel->parms.o_key, RT_TOS(tos), tunnel->parms.link,
 			    tunnel->fwmark);
+	}
 
 	if (ip_tunnel_encap(skb, tunnel, &protocol, &fl4) < 0)
 		goto tx_error;
 
-	rt = connected ? dst_cache_get_ip4(&tunnel->dst_cache, &fl4.saddr) :
-			 NULL;
+	if(ipip_dst_cache_use_mark) {
+		rt = connected ?
+			dst_cache_get_ip4_use_mark(&tunnel->dst_cache, &fl4.saddr,
+					skb->mark) : NULL;
+	} else {
+		rt = connected ? dst_cache_get_ip4(&tunnel->dst_cache, &fl4.saddr)
+					: NULL;
+	}
 
 	if (!rt) {
 		rt = ip_route_output_key(tunnel->net, &fl4);
@@ -787,9 +810,15 @@ void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,
 			dev->stats.tx_carrier_errors++;
 			goto tx_error;
 		}
-		if (connected)
-			dst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,
+		if (connected) {
+			if(ipip_dst_cache_use_mark) {
+				dst_cache_set_ip4_use_mark(&tunnel->dst_cache,
+					  &rt->dst, fl4.saddr, fl4.flowi4_mark);
+			} else {
+				dst_cache_set_ip4(&tunnel->dst_cache, &rt->dst,
 					  fl4.saddr);
+			}
+		}
 	}
 
 	if (rt->dst.dev == dev) {
-- 
2.34.1

